<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Java, daily">
    <meta name="description" content="日常">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>Java | 水兽的Blog</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>
    <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
<meta name="generator" content="Hexo 5.4.0"></head>




<body>
    <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
    <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
    <script type="text/javascript" src="/js/fireworks.js"></script>
    <script type="text/javascript">
        //只在桌面版网页启用特效
        var windowWidth = $(window).width();
        if (windowWidth > 768) {
            document.write('<script type="text/javascript" src="/js/sakura.js"><\/script>');
        }
        </script>
        <script src="/js/cursor.js"></script>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">水兽的Blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">水兽的Blog</div>
        <div class="logo-desc">
            
            日常
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/2.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Java</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/note/">
                                <span class="chip bg-color">note</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-05-09
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2022-03-07
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    24.7k
                </div>
                

                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        

        
        <!-- 代码块折行 -->
        <style type="text/css">
            code[class*="language-"], pre[class*="language-"] { white-space: pre-wrap !important; }
        </style>
        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="1-Collection"><a href="#1-Collection" class="headerlink" title="1.Collection"></a>1.Collection</h2><h3 id="1-1集合知识回顾"><a href="#1-1集合知识回顾" class="headerlink" title="1.1集合知识回顾"></a>1.1集合知识回顾</h3><p>集合的特点：提供一种存储空间可变的存储模型，存储的数据容量可随时发生改变</p>
<h3 id="1-2集合类体系结构"><a href="#1-2集合类体系结构" class="headerlink" title="1.2集合类体系结构"></a>1.2集合类体系结构</h3><p><img src="C:\Users\15135\AppData\Roaming\Typora\typora-user-images\image-20211203203333893.png" alt="image-20211203203333893"></p>
<p>Collection：单列</p>
<ul>
<li>List：可重复<ul>
<li>ArrayList</li>
<li>LinkedList</li>
<li>…</li>
</ul>
</li>
<li>Set：不可重复<ul>
<li>HashSet</li>
<li>TreeSet</li>
<li>…</li>
</ul>
</li>
</ul>
<p>Map：双列</p>
<ul>
<li>HashMap</li>
<li>…</li>
</ul>
<h3 id="1-3Collection集合概述和使用"><a href="#1-3Collection集合概述和使用" class="headerlink" title="1.3Collection集合概述和使用"></a>1.3Collection集合概述和使用</h3><p>Collection集合概述</p>
<ul>
<li>是单例集合的顶层接口，它表示一组对象，这些对象也称为Collection的元素</li>
<li>JDK不提供此接口的任何直接实现，它提供更具体的子接口（如Set和List）实现</li>
</ul>
<p>创建Collection集合的对象</p>
<ul>
<li>多态的方式</li>
<li>具体的实现类ArrayList</li>
</ul>
<h3 id="1-4Collection集合常用方法"><a href="#1-4Collection集合常用方法" class="headerlink" title="1.4Collection集合常用方法"></a>1.4Collection集合常用方法</h3><ul>
<li>boolean add(E e)：添加元素，永远返回true。ps：Alt+7 打开一个窗口，能够看到类的所有信息</li>
<li>boolean remove(Object o)：从集合中移除指定的元素</li>
<li>void clear()：清空集合中的元素</li>
<li>boolean contains(Object o)：判断集合中是否存在指定的元素</li>
<li>boolean isEmpty()：判断集合是否为空</li>
<li>int size()：集合的长度，也是集合中元素的个数</li>
</ul>
<h3 id="1-5Collection集合的遍历"><a href="#1-5Collection集合的遍历" class="headerlink" title="1.5Collection集合的遍历"></a>1.5Collection集合的遍历</h3><p>Iterator：迭代器，集合的专用遍历方式</p>
<ul>
<li>Iterator<E> iterator()：返回此集合中元素的迭代器，通过集合的Iterator()方法得到</li>
<li>迭代器是通过集合的iterator方法得到的，所以我们说它是依赖于集合而存在的</li>
</ul>
<p>Iterator中的常用方法：</p>
<ul>
<li>E next()：返回迭代中的下一个元素</li>
<li>boolean hasNext()：如果迭代具有更多元素，则返回true</li>
</ul>
<h3 id="1-6集合的使用步骤"><a href="#1-6集合的使用步骤" class="headerlink" title="1.6集合的使用步骤"></a>1.6集合的使用步骤</h3><p>步骤一：创建集合对象</p>
<p>步骤二：添加元素到集合</p>
<ul>
<li>创建元素</li>
<li>添加元素到集合</li>
</ul>
<p>步骤三：遍历集合</p>
<ul>
<li>通过集合对象获取迭代器对象</li>
<li>通过迭代器对象的hasNext()方法判断是否还有元素</li>
<li>通过迭代器对象的next方法获取下一个</li>
</ul>
<h2 id="2-List"><a href="#2-List" class="headerlink" title="2.List"></a>2.List</h2><h3 id="2-1List集合概述和特点"><a href="#2-1List集合概述和特点" class="headerlink" title="2.1List集合概述和特点"></a>2.1List集合概述和特点</h3><p>List集合概述</p>
<ul>
<li>有序集合（也称为序列），用户可以精确控制列表中每个元素的插入位置，用户可以通过整数索引访问元素，斌搜索列表中的元素</li>
<li>与Set集合不同，列表通常允许重复的元素</li>
</ul>
<p>List集合特点  </p>
<ul>
<li>有序：存储和取出的元素顺序一致</li>
<li>可重复：存储的元素可以重复</li>
</ul>
<h2 id="2-2List集合特有方法"><a href="#2-2List集合特有方法" class="headerlink" title="2.2List集合特有方法"></a>2.2List集合特有方法</h2><p>void add(int index,E element)：在此集合中的指定位置插入指定的元素</p>
<p>E remove(int index)：删除指定索引处的元素，返回被删除的元素</p>
<p>E set(int index,E element)：修改指定索引处的元素，返回被修改的元素</p>
<p>E get(int index)：返回指定索引处的元素</p>
<p>List循环遍历：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    Stirng s = list.get(i);</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例：遍历学生信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bilibili.Collection;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//    创建collection集合对象</span></span><br><span class="line">        Collection&lt;Student&gt; c = <span class="keyword">new</span> ArrayList&lt;Student&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//    创建学生对象</span></span><br><span class="line">        Student s1 = <span class="keyword">new</span> Student(<span class="string">&quot;周润发&quot;</span>,<span class="number">50</span>);</span><br><span class="line">        Student s2 = <span class="keyword">new</span> Student(<span class="string">&quot;彭于晏&quot;</span>,<span class="number">50</span>);</span><br><span class="line">        Student s3 = <span class="keyword">new</span> Student(<span class="string">&quot;张国荣&quot;</span>,<span class="number">34</span>);</span><br><span class="line">        Student s4 = <span class="keyword">new</span> Student(<span class="string">&quot;张国荣&quot;</span>,<span class="number">34</span>);</span><br><span class="line"><span class="comment">//    把学生添加到集合</span></span><br><span class="line">        c.add(s1);</span><br><span class="line">        c.add(s2);</span><br><span class="line">        c.add(s3);</span><br><span class="line">        c.add(s4);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        迭代器遍历集合</span></span><br><span class="line">        Iterator&lt;Student&gt; it = c.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">            Student s = it.next();</span><br><span class="line">            System.out.println(s.getName()+<span class="string">&quot;,&quot;</span>+s.getAge());</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//		for循环方式        </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c.size(); i++) &#123;</span><br><span class="line">            String s = c.get(i);</span><br><span class="line">            System.out.println(s.getName()+<span class="string">&quot;,&quot;</span>+s.getAge());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-3并发修改异常"><a href="#2-3并发修改异常" class="headerlink" title="2.3并发修改异常"></a>2.3并发修改异常</h3><p>并发修改异常：</p>
<ul>
<li>ConcurrentModificationException：当不允许这样的修改时，可以通过检测到对象的并发修改的方法来抛出此异常</li>
</ul>
<p>产生原因：</p>
<ul>
<li>迭代器遍历的过程中，通过集合对象修改了集合中元素的长度，造成了迭代器获取元素中判断预期修改值和实际修改值不一致</li>
</ul>
<p>解决方案：</p>
<ul>
<li>用for循环遍历，然后用集合对象做对应的操作即可</li>
</ul>
<h3 id="2-4ListIterator"><a href="#2-4ListIterator" class="headerlink" title="2.4ListIterator"></a>2.4ListIterator</h3><p>ListIterator：列表迭代器</p>
<ul>
<li>通过List集合的ListIterator()方法得到，所以说它是List集合特有的迭代器</li>
</ul>
<p>ListIterator中的常用方法：</p>
<ul>
<li>E next()：返回迭代中的下一个元素</li>
<li>boolean hasNext()：如果迭代具有更多元素，则返回true</li>
<li>E previous()：返回列表中的上一个元素</li>
<li>boolean hasPrevious()：如果此列表迭代器在相反方向列表时具有更多元素，则返回true</li>
<li>void add(E e)：将指定的元素插入列表</li>
</ul>
<p>ListIterator不会触发并发修改异常</p>
<h3 id="2-5增强for循环"><a href="#2-5增强for循环" class="headerlink" title="2.5增强for循环"></a>2.5增强for循环</h3><p>增强for：简化数组和Collection集合的遍历</p>
<ul>
<li>实现Iterable接口的类允许其对象称为增强型for语句的目标</li>
<li>它是JDK5之后出现的，其内部原理是一个Iterator迭代器</li>
<li>内部原理就是一个Iterator迭代器</li>
</ul>
<p>增强for的格式</p>
<ul>
<li>格式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(元素数据类型 变量名: 数组或是Collection集合) &#123;</span><br><span class="line">    <span class="comment">//在此处使用变量即可，该变量就是元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>范例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i:arr) &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-6数据结构"><a href="#2-6数据结构" class="headerlink" title="2.6数据结构"></a>2.6数据结构</h3><h4 id="常见数据结构值栈"><a href="#常见数据结构值栈" class="headerlink" title="常见数据结构值栈"></a>常见数据结构值栈</h4><p>数据进入栈模型的过程称为：压/进栈</p>
<p>数据离开栈模型的过程称为：弹/出栈 </p>
<p>栈是一种数据先进后出的模型</p>
<p><img src="C:\Users\15135\AppData\Roaming\Typora\typora-user-images\image-20211206195459590.png" alt="image-20211206195459590"></p>
<h4 id="常见数据结构之队列"><a href="#常见数据结构之队列" class="headerlink" title="常见数据结构之队列"></a>常见数据结构之队列</h4><ul>
<li>数据从后端进入队列模型的过程称为：入队列</li>
<li>数据从前端离开队列模型的过程称为：出队列</li>
</ul>
<p><img src="C:\Users\15135\AppData\Roaming\Typora\typora-user-images\image-20211206195800922.png" alt="image-20211206195800922"></p>
<h4 id="常见数据结构之数组"><a href="#常见数据结构之数组" class="headerlink" title="常见数据结构之数组"></a>常见数据结构之数组</h4><ul>
<li><p>数组时一种查询快，增删慢的模型</p>
</li>
<li><p>查询数据通过索引定位，查询任意数据耗时相同，查询效率高</p>
</li>
<li><p>删除数据时，要求将原始数据删除，同时后面每个数据迁移，删除效率低 </p>
</li>
<li><p>添加数据时，添加位置后的每个数据后移，再添加元素，添加效率极低</p>
</li>
</ul>
<h4 id="常见数据结构之链表"><a href="#常见数据结构之链表" class="headerlink" title="常见数据结构之链表"></a>常见数据结构之链表</h4><p><img src="C:\Users\15135\AppData\Roaming\Typora\typora-user-images\image-20211206200234449.png" alt="image-20211206200234449"></p>
<ul>
<li>链表是一种增删快的模型（对比数组）</li>
<li>链表是一种查询慢的模型（对比数组）</li>
</ul>
<h4 id="2-7-List集合子类特点"><a href="#2-7-List集合子类特点" class="headerlink" title="2.7 List集合子类特点"></a>2.7 List集合子类特点</h4><p>List集合常用子类：ArrayList，linkedList</p>
<ul>
<li>ArrayList：底层数据结构是数组，查询快，增删慢</li>
<li>LinkedList：底层数据结构是链表，查询慢，增删快</li>
</ul>
<h3 id="LinkedList集合的特有功能"><a href="#LinkedList集合的特有功能" class="headerlink" title="LinkedList集合的特有功能"></a>LinkedList集合的特有功能</h3><ul>
<li>public void addFirst(E e)：在该列表开头插入指定元素</li>
<li>public void addLast(E e)：将指定的元素追加到此列表的末尾</li>
<li>public E getFirst()：返回此列表中的第一个元素</li>
<li>public E getLast()：返回此列表中的最后一个元素</li>
<li>public E removeFirst()：从此列表中删除并返回第一个元素</li>
<li>public E removeLat()：从此列表中删除并返回最后一个元素</li>
</ul>
<h3 id="3-1Set集合概述和特点"><a href="#3-1Set集合概述和特点" class="headerlink" title="3.1Set集合概述和特点"></a>3.1Set集合概述和特点</h3><h4 id="Set集合特点"><a href="#Set集合特点" class="headerlink" title="Set集合特点"></a>Set集合特点</h4><ul>
<li>不包含重复元素的集合</li>
<li>没有带索引的方法，所以不能使用普通的for循环遍历</li>
</ul>
<h4 id="Set集合案例：存储字符串并遍历"><a href="#Set集合案例：存储字符串并遍历" class="headerlink" title="Set集合案例：存储字符串并遍历"></a>Set集合案例：存储字符串并遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bilibili.Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SetDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        创建集合对象</span></span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line"><span class="comment">//        添加元素</span></span><br><span class="line">        set.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        遍历</span></span><br><span class="line">        <span class="keyword">for</span>(String s: set) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-2哈希值"><a href="#3-2哈希值" class="headerlink" title="3.2哈希值"></a>3.2哈希值</h3><ul>
<li><p>哈希值：是JDK根据对象的地址或字符串或数字计算出来的int类型的数值</p>
<ul>
<li>```java<br>public int hashCode()//返回对象的哈希码值，默认情况下，相同对象的哈希值是相同的，不同的对象的哈希值是不同的<br>//通过方法重写，可以实现不同对象的哈希值是相同的<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 对象的哈希值特点：</span><br><span class="line"></span><br><span class="line">  * 同一个对象多次调用hashCode()方法返回的哈希值是相同的</span><br><span class="line">  * 默认情况下，不同对象的哈希值是不同的。而重写hashCode()方法，可以实现让不同对象的哈希值相同</span><br><span class="line"></span><br><span class="line">### 3.3HashSet集合概述和特点</span><br><span class="line"></span><br><span class="line">#### Hash集合特点</span><br><span class="line"></span><br><span class="line">* 底层数据结构是哈希表</span><br><span class="line">* 对集合的迭代顺序不作任何保证，也就是说不保证存储和取出的元素顺序一致</span><br><span class="line">* 没有带索引的方法，所以不能使用普通for循环遍历</span><br><span class="line"></span><br><span class="line">* HashSet集合存储元素：要保证元素唯一性，需要重写hashCode()和equals()</span><br><span class="line"></span><br><span class="line">### 3.4常见数据结构之哈希表</span><br><span class="line"></span><br><span class="line">#### 哈希表</span><br><span class="line"></span><br><span class="line">* JDK8之前，底层采用数组＋链表实现，可以说是一个元素为链表的数组</span><br><span class="line">* JDK8以后，在长度比较长的时候，底层实现了优化</span><br><span class="line"></span><br><span class="line">### 3.5LinkedHashSet集合概述和特点</span><br><span class="line"></span><br><span class="line">#### LinkedHashSet集合特点</span><br><span class="line"></span><br><span class="line">* 哈希表和链表实现的Set接口，具有可预测的迭代次序</span><br><span class="line">* 由链表保证元素有序，也就是说元素的存储和取出的顺序是一致的</span><br><span class="line">* 由哈希表保证元素唯一，也就是说没有重复的元素</span><br><span class="line"></span><br><span class="line">### 3.6TreeSet集合概述和特点</span><br><span class="line"></span><br><span class="line">#### TreeSet集合特点</span><br><span class="line"></span><br><span class="line">* 元素有序，这里的顺序不是指存储和取出的顺序，而是按照一定的规则进行排序，具体排序方法取决于构造方法</span><br><span class="line">  * TreeSet()：根据其元素的自然排序进行排序</span><br><span class="line">  * TreeSet(Comparator comparator)：根据指定的比较器进行排序</span><br><span class="line">* 没有带索引的方法，所以不能使用普通的for循环遍历</span><br><span class="line">* 由于是Set集合，所以不包含重复元素的集合</span><br><span class="line"></span><br><span class="line">### 3.8自然排序comparable的使用</span><br><span class="line"></span><br><span class="line">* 存储学生对象并遍历，创建TreeSet集合使用无参构造方法</span><br><span class="line"></span><br><span class="line">* 要求：按照年龄从小到大排序，年龄相同时，按照姓名的字母进行顺序排序</span><br><span class="line"></span><br><span class="line">  * &#96;&#96;&#96;java</span><br><span class="line">    package com.bilibili.Collection;</span><br><span class="line">    </span><br><span class="line">    import java.util.TreeSet;</span><br><span class="line">    </span><br><span class="line">    public class TreeSetDemo2 &#123;</span><br><span class="line">        public static void main(String[] args) &#123;</span><br><span class="line">    &#x2F;&#x2F;        创建集合对象</span><br><span class="line">            TreeSet&lt;Student1&gt; ts &#x3D; new TreeSet&lt;Student1&gt;();</span><br><span class="line">    </span><br><span class="line">            Student1 s1 &#x3D; new Student1(&quot;xishi&quot;,29);</span><br><span class="line">            Student1 s2 &#x3D; new Student1(&quot;wangzhaojun&quot;,28);</span><br><span class="line">            Student1 s3 &#x3D; new Student1(&quot;diaochan&quot;,30);</span><br><span class="line">            Student1 s4 &#x3D; new Student1(&quot;yangyuhaun&quot;,33);</span><br><span class="line">    </span><br><span class="line">            Student1 s5 &#x3D; new Student1(&quot;linqingxia&quot;,33);</span><br><span class="line">            Student1 s6 &#x3D; new Student1(&quot;linqingxia&quot;,33);</span><br><span class="line">            ts.add(s1);</span><br><span class="line">            ts.add(s2);</span><br><span class="line">            ts.add(s3);</span><br><span class="line">            ts.add(s4);</span><br><span class="line">            ts.add(s5);</span><br><span class="line">            ts.add(s6);</span><br><span class="line">    </span><br><span class="line">            for(Student1 s : ts) &#123;</span><br><span class="line">                System.out.println(s.getName() + &quot;，&quot; + s.getAge());</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;Student1类</span><br><span class="line">    class Student1 implements Comparable&lt;Student1&gt;&#123;</span><br><span class="line">        String name;</span><br><span class="line">        int age;</span><br><span class="line">    </span><br><span class="line">        public Student1(String name, int age) &#123;</span><br><span class="line">            this.name &#x3D; name;</span><br><span class="line">            this.age &#x3D; age;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        public Student1() &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        public String getName() &#123;</span><br><span class="line">            return name;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        public void setName(String name) &#123;</span><br><span class="line">            this.name &#x3D; name;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        public int getAge() &#123;</span><br><span class="line">            return age;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        public void setAge(int age) &#123;</span><br><span class="line">            this.age &#x3D; age;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        @Override</span><br><span class="line">        public boolean equals(Object o) &#123;</span><br><span class="line">            if (this &#x3D;&#x3D; o) return true;</span><br><span class="line">            if (o &#x3D;&#x3D; null || getClass() !&#x3D; o.getClass()) return false;</span><br><span class="line">            Student1 student1 &#x3D; (Student1) o;</span><br><span class="line">            return age &#x3D;&#x3D; student1.age &amp;&amp; Objects.equals(name, student1.name);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        @Override</span><br><span class="line">        public int hashCode() &#123;</span><br><span class="line">            return Objects.hash(name, age);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        @Override</span><br><span class="line">        public int compareTo(Student1 s) &#123;</span><br><span class="line">    &#x2F;&#x2F;        return 0;</span><br><span class="line">    &#x2F;&#x2F;        return 1;</span><br><span class="line">    &#x2F;&#x2F;        return -1;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;        按照年龄从小到大排序</span><br><span class="line">    &#x2F;&#x2F;        int num &#x3D; this.age - s.age;</span><br><span class="line">            int num &#x3D; s.age - this.age;</span><br><span class="line">    &#x2F;&#x2F;        年龄相同时，按照姓名的字母进行顺序排序</span><br><span class="line">            int num2 &#x3D; num &#x3D;&#x3D; 0 ? this.name.compareTo(s.name):num;</span><br><span class="line">            return num2;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><ul>
<li>用TreeSet集合存储自定义对象，无参构造方法使用的是自然排序对元素进行排序的</li>
<li>自然排序，就是让元素所属的类实现comparable接口，重写comparaTo(T o)方法</li>
<li>重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写</li>
</ul>
<h3 id="3-9比较器排序Comparator的使用"><a href="#3-9比较器排序Comparator的使用" class="headerlink" title="3.9比较器排序Comparator的使用"></a>3.9比较器排序Comparator的使用</h3><ul>
<li>存储学生对象并遍历，创建TreeSet集合使用带参构造方法</li>
<li>要求：按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序排序</li>
</ul>
<h4 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h4><ul>
<li>用TreeSet集合存储自定义对象，带参构造方法使用的是比较器排序对元素进行排序的</li>
<li>比较器排序，就是让集合构造方法接收Comparator的实现类对象，重写compare(T o1, T o2)方法</li>
<li>重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写</li>
</ul>
<h2 id="4-泛型"><a href="#4-泛型" class="headerlink" title="4.泛型"></a>4.泛型</h2><h3 id="4-1泛型概述"><a href="#4-1泛型概述" class="headerlink" title="4.1泛型概述"></a>4.1泛型概述</h3><p>泛型：是JDK5中引入的特性，它提供了编译时类型安全检测机制，该机制允许在编译时检测到非法的类型，它的本质是<em>参数化类型</em>，也就是说所操作的数据类型被指定为一个参数。</p>
<p>一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参，那么如何理解参数化类型？</p>
<p>顾名思义，就是将类型由原来具体的类型参数化，然后在调用/使用时传入具体的类型</p>
<p>这种参数类型可以用在类、方法和接口中，分别被称为泛型类、泛型方法、泛型接口</p>
<h4 id="泛型的定义格式："><a href="#泛型的定义格式：" class="headerlink" title="泛型的定义格式："></a>泛型的定义格式：</h4><ul>
<li>&lt;类型&gt;：指定一种类型的格式。这里的类型可以看成是形参</li>
<li>&lt;类型1,类型2…&gt;：指定多种类型的格式，多种类型之间用逗号隔开。这里的类型可以看成是形参</li>
<li>将来具体调用时给定的类型可以看成是实参，并且实参的类型只能是引用数据类型</li>
</ul>
<h4 id="泛型的好处："><a href="#泛型的好处：" class="headerlink" title="泛型的好处："></a>泛型的好处：</h4><ul>
<li>把运行期间的问题提前到了编译期间</li>
<li>避免了强制类型转换</li>
</ul>
<h3 id="4-2泛型类"><a href="#4-2泛型类" class="headerlink" title="4.2泛型类"></a>4.2泛型类</h3><h4 id="泛型类的定义格式："><a href="#泛型类的定义格式：" class="headerlink" title="泛型类的定义格式："></a>泛型类的定义格式：</h4><ul>
<li>格式：修饰符 class 类名&lt;类型&gt;{}</li>
<li>范例：public class Generic<T> {}<ul>
<li>此处T可以写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</li>
</ul>
</li>
</ul>
<h3 id="4-3泛型方法"><a href="#4-3泛型方法" class="headerlink" title="4.3泛型方法"></a>4.3泛型方法</h3><h4 id="泛型方法的定义格式："><a href="#泛型方法的定义格式：" class="headerlink" title="泛型方法的定义格式："></a>泛型方法的定义格式：</h4><ul>
<li>格式：修饰符 &lt;类型&gt; 返回值类型 方法名(类型 变量名){}</li>
<li>范例：public <T> void show(T t){}</li>
</ul>
<h3 id="4-4泛型接口"><a href="#4-4泛型接口" class="headerlink" title="4.4泛型接口"></a>4.4泛型接口</h3><h4 id="泛型接口的定义形式："><a href="#泛型接口的定义形式：" class="headerlink" title="泛型接口的定义形式："></a>泛型接口的定义形式：</h4><ul>
<li>格式：修饰符 interface 接口名 &lt;类型&gt; {}</li>
<li>范例：public interface Generic<T>{}</li>
</ul>
<h3 id="4-5类型通配符"><a href="#4-5类型通配符" class="headerlink" title="4.5类型通配符"></a>4.5类型通配符</h3><p>为了表示各种泛型List的父类，可以使用类型通配符</p>
<ul>
<li>类型通配符：&lt;?&gt;</li>
<li>List&lt;?&gt;：表示元素类型未知的List，它的元素可以匹配任何的类型</li>
<li>这种带通配符的List仅表示它是各种泛型List的父亲，并不能把元素添加到其中</li>
</ul>
<p>如果说我们不希望List&lt;?&gt;是任何泛型List的父类，只希望它代表某一类泛型List的父类，可以使用类型通配符的上限</p>
<ul>
<li>类型通配符上限：&lt;? extends 类型&gt;</li>
<li>List&lt;? extends Number&gt;：它表示的类型是Number或者其子类型</li>
</ul>
<p>除了可以指定类型通配符的上限，我们也可以指定类型通配符的下限</p>
<ul>
<li>类型通配符下限：&lt;? super 类型&gt;</li>
<li>List&lt;? super Number&gt;：它表示的类型是Number或者其父类型</li>
</ul>
<h3 id="4-6可变参数"><a href="#4-6可变参数" class="headerlink" title="4.6可变参数"></a>4.6可变参数</h3><p>可变参数又称为参数个数可变，用作方法的形参出现，那么方法参数个数就是可变的了</p>
<ul>
<li>格式：修饰符 返回值类型 方法名(数据类型… 变量名){}</li>
<li>范例：public static int sum(int… a){}</li>
</ul>
<h4 id="可变参数注意事项"><a href="#可变参数注意事项" class="headerlink" title="可变参数注意事项"></a>可变参数注意事项</h4><ul>
<li>这里的变量其实是一个数组</li>
<li>如果一个方法有多个参数，包括可变参数，可变参数要放在最后</li>
</ul>
<h3 id="4-7可变参数的使用"><a href="#4-7可变参数的使用" class="headerlink" title="4.7可变参数的使用"></a>4.7可变参数的使用</h3><h4 id="Arrays工具类中有一个静态方法："><a href="#Arrays工具类中有一个静态方法：" class="headerlink" title="Arrays工具类中有一个静态方法："></a>Arrays工具类中有一个静态方法：</h4><ul>
<li>public static <T> List<T> asList(T… a)：返回由指定数组支持的固定大小的列表</li>
</ul>
<h4 id="List接口中有一个静态方法："><a href="#List接口中有一个静态方法：" class="headerlink" title="List接口中有一个静态方法："></a>List接口中有一个静态方法：</h4><ul>
<li>public static <E> List<E> of(E… elements)：返回包含任意元素的不可变列表</li>
</ul>
<h4 id="Set接口中有一个静态方法："><a href="#Set接口中有一个静态方法：" class="headerlink" title="Set接口中有一个静态方法："></a>Set接口中有一个静态方法：</h4><p>public static <E> Set<E> of(E… elements)：返回一盒包含任意数量元素的不可变集合</p>
<h1 id="Java图形界面开发"><a href="#Java图形界面开发" class="headerlink" title="Java图形界面开发"></a>Java图形界面开发</h1><h4 id="awt"><a href="#awt" class="headerlink" title="awt"></a>awt</h4><p>awt编译乱码：-Dfile.encoding=gbk</p>
<p>去掉窗体边框：setUndecorated</p>
<h2 id="5-Map"><a href="#5-Map" class="headerlink" title="5.Map"></a>5.Map</h2><h3 id="5-1Map集合概述和使用"><a href="#5-1Map集合概述和使用" class="headerlink" title="5.1Map集合概述和使用"></a>5.1Map集合概述和使用</h3><h4 id="Map集合概述"><a href="#Map集合概述" class="headerlink" title="Map集合概述"></a>Map集合概述</h4><ul>
<li>Interface Map&lt;K,V&gt;    K：键的类型；V：值的类型</li>
<li>将键映射到值的对象；不能包含重复的键；每个键可以映射到最多一个值</li>
</ul>
<h4 id="创建Map集合的对象"><a href="#创建Map集合的对象" class="headerlink" title="创建Map集合的对象"></a>创建Map集合的对象</h4><ul>
<li><p>多态的方式</p>
</li>
<li><p>具体的实现类HashMap</p>
</li>
<li><p>```java<br>//    创建集合对象</p>
<pre><code>public static void main(String[] args) &#123;
    Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;();
</code></pre>
<p>//        V put(K key,V value)将指定的值与该映射中的指定键相关联</p>
<pre><code>    map.put(&quot;itheima001&quot;,&quot;林青霞&quot;);
    map.put(&quot;itheima002&quot;,&quot;张曼玉&quot;);
    map.put(&quot;itheima003&quot;,&quot;王祖贤&quot;);

    System.out.println(map);
&#125;
</code></pre>
<p>}<br>//键是唯一的，键重复时，新值替代旧值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 5.2Map集合的基本功能</span><br><span class="line"></span><br><span class="line">  &#96;&#96;&#96;java</span><br><span class="line">  V put(K key,V value)&#x2F;&#x2F;添加元素</span><br><span class="line">  V remove(Object key)&#x2F;&#x2F;根据键删除键值对元素</span><br><span class="line">  void clear()&#x2F;&#x2F;移除所有的键值对元素</span><br><span class="line">  boolean containsKey(Object key)&#x2F;&#x2F;判断集合是否包含指定的键</span><br><span class="line">  boolean containsValue(Object value)&#x2F;&#x2F;判断集合是否包含指定的键</span><br><span class="line">  boolean isEmpty()&#x2F;&#x2F;判断集合是否为空</span><br><span class="line">  int size()&#x2F;&#x2F;集合的长度，也就是集合中键值对的个数</span><br></pre></td></tr></table></figure>

<h3 id="5-3Map集合的获取功能"><a href="#5-3Map集合的获取功能" class="headerlink" title="5.3Map集合的获取功能"></a>5.3Map集合的获取功能</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">V <span class="title">get</span><span class="params">(Object key)</span><span class="comment">//根据键获取值</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span><span class="comment">//获取所有键的集合</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span><span class="comment">//获取所有值的集合</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Set&lt;Map.Entry&lt;K,V&gt;&gt;<span class="title">entrySet</span><span class="params">()</span><span class="comment">//获取所有键值对对象的集合</span></span></span><br></pre></td></tr></table></figure>

<h3 id="5-4Map集合的遍历（方式1）"><a href="#5-4Map集合的遍历（方式1）" class="headerlink" title="5.4Map集合的遍历（方式1）"></a>5.4Map集合的遍历（方式1）</h3><p>遍历思路：</p>
<ul>
<li>获取所有键的集合，用KeySet方式实现</li>
<li>遍历键的集合，获取到每一个键，用foreach实现</li>
<li>根据键去找值，用get(Object key)方法实现</li>
</ul>
</li>
</ul>
<h3 id="5-5Map集合的遍历（方式2）"><a href="#5-5Map集合的遍历（方式2）" class="headerlink" title="5.5Map集合的遍历（方式2）"></a>5.5Map集合的遍历（方式2）</h3><p>遍历思路：</p>
<ul>
<li>获取所有键值对对象的集合<ul>
<li>Set&lt;Map.Entry&lt;K,V&gt;&gt;entrySet()：获取所有键值对对象的集合</li>
</ul>
</li>
<li>遍历键值对对象的集合，得到每一个键值对对象<ul>
<li>用foreach实现，得到每一个Map.Entry</li>
</ul>
</li>
<li>根据键值对对象获取键和值<ul>
<li>用getKey()得到键</li>
<li>用getValue()得到值</li>
</ul>
</li>
</ul>
<h4 id="案例：统计字符串中每个字符出现的次数"><a href="#案例：统计字符串中每个字符出现的次数" class="headerlink" title="案例：统计字符串中每个字符出现的次数"></a>案例：统计字符串中每个字符出现的次数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        键盘录入一个字符串</span></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一个字符串&quot;</span>);</span><br><span class="line">        String line = sc.nextLine();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        创建HashMap集合，键是Character，值是Integer</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        不进行排序</span></span><br><span class="line"><span class="comment">//        HashMap&lt;Character,Integer&gt; hm = new HashMap&lt;Character,Integer&gt;();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//        按键进行排序</span></span><br><span class="line">        TreeMap&lt;Character,Integer&gt; hm = <span class="keyword">new</span> TreeMap&lt;Character,Integer&gt;();</span><br><span class="line"><span class="comment">//        遍历字符串得到每一个字符</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; line.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> key = line.charAt(i);</span><br><span class="line"></span><br><span class="line">            Integer value = hm.get(key);</span><br><span class="line">            <span class="keyword">if</span>(value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                hm.put(key,<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                value++;</span><br><span class="line">                hm.put(key,value);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        遍历HashMap集合，得到键和值</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        Set&lt;Character&gt; keySet = hm.keySet();</span><br><span class="line">        <span class="keyword">for</span>(Character key : keySet) &#123;</span><br><span class="line">            Integer value = hm.get(key);</span><br><span class="line">            sb.append(key).append(<span class="string">&quot;(&quot;</span>).append(value).append(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String result = sb.toString();</span><br><span class="line">        System.out.println(result);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-Collections"><a href="#6-Collections" class="headerlink" title="6.Collections"></a>6.Collections</h2><h3 id="6-1Collections概述和使用"><a href="#6-1Collections概述和使用" class="headerlink" title="6.1Collections概述和使用"></a>6.1Collections概述和使用</h3><h4 id="Collections类的概述"><a href="#Collections类的概述" class="headerlink" title="Collections类的概述"></a>Collections类的概述</h4><ul>
<li>是针对集合操作的工具类</li>
</ul>
<h4 id="Collections类的常用方法"><a href="#Collections类的常用方法" class="headerlink" title="Collections类的常用方法"></a>Collections类的常用方法</h4><ul>
<li><p>public static&lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List<T> list)：将指定的列表按升序排列</p>
</li>
<li><p>public static void reverse(List&lt;?&gt; list)：反转指定列表中元素的顺序</p>
</li>
<li><p>public static void shuffle(List&lt;?&gt; list)：使用默认的随机源排序指定的列表</p>
</li>
<li><p>```java<br>List<Integer> list = new ArrayList<Integer>();</p>
<p>//添加元素</p>
<p>list.add(30);<br>list.add(20);<br>list.add(10);<br>list.add(40);<br>list.add(50);</p>
<p>Collections.sort(list);</p>
<p>Collections.reverse(list);</p>
<p>Collections.shuffle(list);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* </span><br><span class="line"></span><br><span class="line">## awt布局</span><br><span class="line">BorderLayout</span><br><span class="line">FlowLayout</span><br><span class="line">GridLayout</span><br><span class="line">GridBagLayout</span><br><span class="line">CardLayout</span><br><span class="line">BoxLayout(swing)</span><br><span class="line"></span><br><span class="line">## awt中常用组件</span><br><span class="line"></span><br><span class="line">Button 按钮</span><br><span class="line">Canvas 画布</span><br><span class="line">Checkbox 复选框</span><br><span class="line">CheckboxGroup 将多个Checkbox 组合成一组，一组Checkbox中将只有一个会被选中，即全部变成单选框组件</span><br><span class="line">Choice 下拉选框</span><br><span class="line">Frame 窗口，在GUI程序里通过该类创建窗口</span><br><span class="line">Label 标签类，用于放置提示性文本</span><br><span class="line">List 列表框组件，可以添加多条项目</span><br><span class="line">Panel 不能单独存在容器内，必须存在其他容器中</span><br><span class="line">Scrollbar 滚动条组件。如果需要用户输入某个范围内的值，就可以使用滚动条组件，定义一个滚动条时，必须指定它的方向，初始值，滑块的大小，最小值和最大值。</span><br><span class="line">ScrollPane 带水平及垂直滚动条的容器</span><br><span class="line">TextArea 多行容器</span><br><span class="line">TextField 单行文本框</span><br><span class="line"></span><br><span class="line">### Dialog 对话框</span><br><span class="line">Dialog(Frame owner,String title,boolean modal)</span><br><span class="line">模式对话框 不可以对父类容器做操作</span><br><span class="line">非模式对话框 可以对父类容器做操作</span><br><span class="line"></span><br><span class="line">### FileDialog 文件对话框</span><br><span class="line">FileDialog(Frame parent,String title,int mode)  parent指父窗口 mode指文件对话类型。 例如FileDialog.LOAD,用于打开了文件 FileDialog.SAVE用于保存文件</span><br><span class="line"></span><br><span class="line">记得设置fileDialog窗口可视化</span><br><span class="line"></span><br><span class="line">String getDirectory()获取被打开或保存文件的绝对路径</span><br><span class="line"></span><br><span class="line">String getFile() 获取被打开或者保存的文件名</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## GUI常见事件和事件监听器</span><br><span class="line"></span><br><span class="line">### 低级事件</span><br><span class="line">ComponentEvent 组件事件</span><br><span class="line">ContainerEvent 容器事件</span><br><span class="line">WindowEvent 窗口事件</span><br><span class="line">FocusEvent 焦点事件</span><br><span class="line">KeyEvent 键盘事件</span><br><span class="line">MouseEvent 鼠标事件</span><br><span class="line">PaintEvent 组件绘制事件</span><br><span class="line"></span><br><span class="line">### 高级事件</span><br><span class="line">ActionEvent 动作事件，党按钮，菜单项被单击，在TextFiled中按Enter时触发</span><br><span class="line">AjustmentEvent 调节事件，在滑动条上移动滑块调节数值时触发该事件</span><br><span class="line">ItemEvent 选项事件，当用户选中某项，或取消选中某项时触发该事件</span><br><span class="line">TextEvent 文本事件，当文本框、文本域中的文本发生改变时触发该事件</span><br><span class="line"></span><br><span class="line">### 事件监听器</span><br><span class="line">MouseMotionListener 鼠标移动</span><br><span class="line"></span><br><span class="line">## 菜单组件</span><br><span class="line">MenuBar 菜单条，菜单的容器</span><br><span class="line">Menu 菜单组件，菜单项的容器，也是MenuItem的子类，所以可以作为菜单项使用</span><br><span class="line">PopupMenu 上下文菜单组件（右键菜单组件）</span><br><span class="line">MenuItem 菜单项组件</span><br><span class="line">CheckboxMenuItem 复选框菜单组件</span><br><span class="line"></span><br><span class="line">## 绘图</span><br><span class="line"></span><br><span class="line">### 绘图组件</span><br><span class="line">paint(Graphics g) 绘制组件的外观</span><br><span class="line">update(Graphics g) 内部调用paint方法，刷新组件外观</span><br><span class="line">repaint() 调用uodate方法，刷新组件外观</span><br><span class="line"></span><br><span class="line">#### Graphics类</span><br><span class="line">setColor(Color c) 设置颜色</span><br><span class="line">setFont(Font font) 设置字体</span><br><span class="line">drawLine() 绘制直线</span><br><span class="line">drawRectIO 绘制矩形</span><br><span class="line">drawRoundRect() 绘制圆角矩形</span><br><span class="line">drawOyal() 绘制椭圆形</span><br><span class="line">drawPolygon() 绘制多边形</span><br><span class="line">drawArc() 绘制圆弧</span><br><span class="line">drawPolyline() 绘制折线</span><br><span class="line">fillRoundRect() 填充圆角矩形区域</span><br><span class="line">fillOval() 填充椭圆区域</span><br><span class="line">fillRect() 填充多边形区域</span><br><span class="line">fillRect() 填充圆弧对应的扇形区域</span><br><span class="line">drawImage() 绘制位图</span><br><span class="line"></span><br><span class="line">#### BUfferedImage位图对象</span><br><span class="line">位图使用步骤：</span><br><span class="line">----------------</span><br><span class="line">1.创建Image的子类对象BufferedImage(int width,int height,int ImageType)，创建时需要指定位图的宽高以及类型属性；此时相当于在内存中生成了一张图片。</span><br><span class="line">2.调用BufferedImage对象的getGraphics()方法获取画笔，此时就可以往内存中的图片上绘图了。</span><br><span class="line">3.调用组件中paint方法提供的Graphics对象的drawImage()方法，一次性内存中的图片BufferedImage绘制到特定的组件上。</span><br><span class="line"></span><br><span class="line">### ImageIO的使用</span><br><span class="line">static BufferedImage read(File input) 读取本地磁盘图片文件</span><br><span class="line">static BufferedImage read(InputStream input) 读取本地磁盘图片文件</span><br><span class="line">static boolean write(RenderedImage im,String formatName,File output) 往本地磁盘中输出图片文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----------</span><br><span class="line">## Swing</span><br><span class="line">概述：Swing由百分百纯java实现，不再依赖于本地平台的GUI，因此可以在所有平台上都保持相同的界面外观。独立于本地平台的Swing组件被称为轻量组件，依赖于本地平台的AWT被称为重量级组件。</span><br><span class="line"></span><br><span class="line">特征：Swing组件采用MVC(Model-View-Controller，即模型-视图-控制器)设计模式</span><br><span class="line">模型：用于维护组件的各种状态</span><br><span class="line">视图：是组件的可视化表现</span><br><span class="line">控制器：用于控制对于各种事件&#x2F;组件做出响应。</span><br><span class="line"></span><br><span class="line">----------</span><br><span class="line">### Swing为组件设置边框</span><br><span class="line"></span><br><span class="line">#### 常见Border</span><br><span class="line">BevelBorder</span><br><span class="line">LineBorder</span><br><span class="line">EmptyBorder</span><br><span class="line">EtchedBorder</span><br><span class="line">TitledBorder</span><br><span class="line">MatteBorder</span><br><span class="line">CompoundBorder</span><br><span class="line"></span><br><span class="line">#### 特殊的Border</span><br><span class="line">TitleBorder：它的作用并不是直接为其他组件添加边框，而是为其他边框设置标题，创建该类对象时，需要传入一个其他的Border对象。</span><br><span class="line">CompoundBorder：用来组合其他两个边框，创建该类对象时，需要传入其他两个Border对象，一个作为内边框，一个作为外边框。</span><br><span class="line"></span><br><span class="line">#### 给组件设置边框步骤</span><br><span class="line">1.使用BorderFactory或者XxxBorder创建Border的实例对象。</span><br><span class="line">2.调用Swing组件的setBorder（Border b）方法为组件设置边框。</span><br><span class="line"></span><br><span class="line">### 使用JtoolBar创建工具条</span><br><span class="line"></span><br><span class="line">### JColorChooser和JFileChooser</span><br><span class="line"></span><br><span class="line">#### JColorChooser</span><br><span class="line">JColorChooser用于创建颜色选择器对话框，只需调用它的静态方法就可快速生成一个颜色选择对话框。</span><br><span class="line">public static Color showDialog(Component component,String title,Color initialColor) </span><br><span class="line">参数：component：指定当前对话框的父组件。</span><br><span class="line">    title：当前对话框的名称</span><br><span class="line">    initialColor：指定默认选中的颜色</span><br><span class="line">返回值：返回用户选中的颜色</span><br><span class="line"></span><br><span class="line">#### JFileChooser</span><br><span class="line"></span><br><span class="line">##### 1.创建JFileChooser对象</span><br><span class="line">JFileChooser chooser &#x3D; new JFileChooser(&quot;D:\\&quot;); &#x2F;&#x2F;指定默认打开的本地磁盘路径</span><br><span class="line"></span><br><span class="line">##### 2.调用JFileChoose的一系列可选方法，进行初始化</span><br><span class="line">setSelectedFile(File file)&#x2F;setSelectedFiles(File[] selectedFiles)：设置默认选中的文件</span><br><span class="line">setMultiSelectionEnabled(boolean b)：设置是否允许多选，默认是单选</span><br><span class="line">setFileSelectionMode(int mode)：设置可以选择内容，例如文件、文件夹等，默认只能选择文件</span><br><span class="line"></span><br><span class="line">##### 3.打开文件对话框</span><br><span class="line">showOpenDialog(Component parent)：打开文件加载对话框，并指定父组件</span><br><span class="line">showSaveDialog(Component parent)：打开文件保存对话框，并指定父组件</span><br><span class="line"></span><br><span class="line">##### 4.获取用户选择的结果</span><br><span class="line">File getSelectedFile()：获取用户选择的一个文件</span><br><span class="line">File[] getSelectedFiles()：获取用户选择的多个文件</span><br><span class="line"></span><br><span class="line">### JOptionPane</span><br><span class="line"></span><br><span class="line">----------</span><br><span class="line"></span><br><span class="line">基本描述：</span><br><span class="line">通过JOptionPane可以非常方便地创建一些简单地对话框，Swing已经为这些对话框添加了相应的组件，无须手动添加组件。JOptionPane提供了如下4个方法来创建对话框。</span><br><span class="line"></span><br><span class="line">#### showMessageDialog&#x2F;showInternalMessageDialog </span><br><span class="line">消息对话框，告知用户某事已发生，用户只能单击“确定”按钮，类似于JavaScript的alert函数。</span><br><span class="line"></span><br><span class="line">#### showConfirmDialog&#x2F;showInternalConfirmDialog </span><br><span class="line">确认对话框，向用户确认某个问题，用户可以选择yes、no-cancel等选项。类似于JavaScript的confirm函数。该方法返回用户的单击了哪个按钮</span><br><span class="line"></span><br><span class="line">#### showInputDialog&#x2F;showInternalInputDialog</span><br><span class="line">输入对话框，提示要求输入某些信息，类似于JavaScript的prompt函数。该方法返回用户输入的字符串。</span><br><span class="line"></span><br><span class="line">#### showOptionDialog&#x2F;showInternalOptionDialog</span><br><span class="line">自定义选项对话框，允许使用自定义选项，可以取代showConfirmDialog所产生的对话框，只是用起来更复杂。</span><br><span class="line"></span><br><span class="line">---------</span><br><span class="line"></span><br><span class="line">#### 例子</span><br><span class="line">以上方法都有很多重载形式，选择其中一种最全的形式，参数解释如下：</span><br><span class="line">showXxxDialog(Component parentComponent,</span><br><span class="line">        Object message,</span><br><span class="line">        String title,</span><br><span class="line">        int optionType,</span><br><span class="line">        int messageType,</span><br><span class="line">        Icon icon,</span><br><span class="line">        Object[] options,</span><br><span class="line">        Object initialValue)</span><br><span class="line"></span><br><span class="line">参数解释：</span><br><span class="line">parentComponent：当前对话框的父组件</span><br><span class="line">message：对话框上显示的信息，信息可以是字符串、组件、图片等</span><br><span class="line">title：当前对话框的标题</span><br><span class="line">optionType：当前对话框上显示的按钮类型：DEFAULT_OPTION、YES_NO_OPTION、YES_NO_CANCEL_OPTION、OK_CANCEL_OPTION</span><br><span class="line">messageType：当前对话框的类型：ERROR_MESSAGE、INFORMATION_MESSAGE、WARING_MESSAGE</span><br><span class="line">icon：当前对话框左上角的图标</span><br><span class="line">options：自定义下拉列表的选项</span><br><span class="line">initialValue：自定义选项中的默认选中项</span><br><span class="line"></span><br><span class="line">----------</span><br><span class="line"></span><br><span class="line">当用户与对话框交互结束后，不同类型对话框的返回值如下：</span><br><span class="line">showMessageDialog：无返回值。</span><br><span class="line">showInputDialog：返回用户输入或选中的字符串。</span><br><span class="line">showConfirmDialog：返回一个整数代表用户的选项。</span><br><span class="line">showOptionDialog：返回一个整数代表用户的选项，如果用户选第一项，则返回0；如果用户选则第二项，则返回1，以此类推。</span><br><span class="line"></span><br><span class="line">----------</span><br><span class="line"></span><br><span class="line">对showConfirmDialog所产生的对话框，有如下几个返回值</span><br><span class="line"></span><br><span class="line">YES OPTION：用户单击了“是”按钮后返回。</span><br><span class="line">NO OPTION：用户单击了“否”按钮后返回。</span><br><span class="line">CANCEL OPTION：用户单击了“取消”按钮后返回。</span><br><span class="line">OK OPTION：用户单击了“确定”按钮后返回。</span><br><span class="line">CLOSED OPTION：用户单击了对话框右上角的“X”按钮后返回。</span><br><span class="line"></span><br><span class="line">### Swing中的特殊容器</span><br><span class="line"></span><br><span class="line">---------</span><br><span class="line"></span><br><span class="line">#### 使用JSplitPane</span><br><span class="line">通过如下构造方法可以创建JSplitPane对象</span><br><span class="line">JSplitPane(int newOrientation,Component newLeftComponent,Component newRightCompnent)</span><br><span class="line">newOrientation：指定JSplitPane容器的分割方向，如果值为JSplitPane.VERTICAL_SPLIT,为纵向分割，JSplitPane.HORIZONTAL_SPLIT，为横向分割</span><br><span class="line">newLeftComponent：左侧或上侧的组件</span><br><span class="line">newRughtComponent：右侧或下侧的组件</span><br><span class="line"></span><br><span class="line">设置是否开启连续布局的支持（可选）</span><br><span class="line">setContinuousLayout(boolean newContinuousLayout)</span><br><span class="line">默认是关闭的，如果设置为true，则打开连续布局的支持，但由于连续布局支持需要不断地重绘，所以效率会低一些</span><br><span class="line"></span><br><span class="line">设置是否支持“一触即展”地支持（可选）</span><br><span class="line">setOneTouchExpandable(boolean new Value);</span><br><span class="line">默认关闭</span><br><span class="line"></span><br><span class="line">其他设置</span><br><span class="line">setDividerLocation(double proportionalLocation)：设置分割条地位置为JSplitPane的某个百分比</span><br><span class="line">setDividerLocation(int location)：通过像素值设置分割条的位置</span><br><span class="line">setDividerSize(int newSize)：通过像素值设置分割条大小</span><br><span class="line">setLeftComponent(Component comp)：设置指定位置的组件</span><br><span class="line"></span><br><span class="line">#### JTabbedPane</span><br><span class="line"></span><br><span class="line">1.创建JTabbedPane</span><br><span class="line">JTabbedPane(int tabPlacement,int tableLayoutPolicy)</span><br><span class="line">tabPlacement：指定标签的放置位置，可以选择SwingConstants中的四个常量：TOP、LEFT、BOTTOM、RIGHT</span><br><span class="line">tableLayoutPolicy：指定当前窗口不能容纳标签页标题时的布局策略，可以选用JTabbedPane.WRAP_TAB_LAYOUT和JTabbedPane.SCROLL_TAB_LAYOUT。</span><br><span class="line"></span><br><span class="line">2.通过JTabbedPane对象对标签进行增删改查</span><br><span class="line">增加标签：</span><br><span class="line">addTab(String title,Icon icon,Component component,String tip)</span><br><span class="line">title：标签的名称</span><br><span class="line">icon：标签的图标</span><br><span class="line">component：标签对应的组件</span><br><span class="line">tip：光标放到标签上的提示</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">插入标签页：</span><br><span class="line">insertTab(String title,Icon icon,Component component,String tip,int index)</span><br><span class="line">title：标签的名称</span><br><span class="line">icon：标签的图标</span><br><span class="line">component：标签对应的组件</span><br><span class="line">tip：光标放到标签上的提示</span><br><span class="line">index：在哪个索引处插入标签页</span><br><span class="line"></span><br><span class="line">修改标签页对应的组件：</span><br><span class="line">setComponentAt(int index,Component component)</span><br><span class="line">index：在哪个索引处插入标签页</span><br><span class="line">component：标签对应的组件</span><br><span class="line"></span><br><span class="line">删除组件：</span><br><span class="line">removeTabAt(int index)</span><br><span class="line">index：删除哪个索引处的标签</span><br><span class="line"></span><br><span class="line">3.设置当前选中的标签页</span><br><span class="line">setSelectedIndex(int index)</span><br><span class="line"></span><br><span class="line">4.设置JtabbedPane的其他属性</span><br><span class="line">setDisabledIconAt(int index,Icon disabledIcon)</span><br><span class="line">将指定位置的禁用图标设置为icon，该图标也可以是null表示不使用禁用图标。</span><br><span class="line"></span><br><span class="line">setEnableAt(int index,boolean enabled)</span><br><span class="line">设置指定位置的标签页是否启用</span><br><span class="line"></span><br><span class="line">setTitleAt(int index,String title)</span><br><span class="line">设置指定位置标签页的标题为title，该title可以是null，表示该标签页的标题为空</span><br><span class="line"></span><br><span class="line">setToolTipTextAt(int index,String toolTipText)</span><br><span class="line">设置指定位置标签页的提示文本</span><br><span class="line"></span><br><span class="line">5.为JTabbedPane设置监听器</span><br><span class="line">addChangeListener(changeListener listener)</span><br><span class="line"></span><br><span class="line">#### JProgressBar、ProgressMonitor、BoundedRangeModel实现进度条</span><br><span class="line">1.创建JProgress对象</span><br><span class="line">public JProgressBar(int orient,int min,int max)：</span><br><span class="line">orient：方向</span><br><span class="line">min：最小值</span><br><span class="line">max：最大值</span><br><span class="line"></span><br><span class="line">2.设置属性</span><br><span class="line">setBorderPainted(boolean b)：设置进度条是否有边框</span><br><span class="line">setIndeterminate(boolean newValue)：设置当前进度条是不是进度不确定的进度条，如果是，则将看到一个滑块在进度条中左右移动</span><br><span class="line">setStringPainted(boolean b)：设置进度条是否显示当前完成的百分比</span><br><span class="line"></span><br><span class="line">3.获取和设置当前进度条的进度状态</span><br><span class="line">setValue(int n)：设置当前进度值</span><br><span class="line">double getPercentComplete()：获取进度条的完成百分比</span><br><span class="line">String getString()：返回进度字符串的当前值</span><br><span class="line"></span><br><span class="line">创建进度对话框</span><br><span class="line">ProgressMonitor的用法与ProgressBar的用法基本相似</span><br><span class="line">public ProgressMonitor(Component parentComponent,Object message,String note,int min,int max)</span><br><span class="line">parentComponent：对话框的父组件</span><br><span class="line">message：对话框的描述信息</span><br><span class="line">note：对话框的提示信息</span><br><span class="line">min：进度条的最小值</span><br><span class="line">max：进度条的最大值</span><br><span class="line"></span><br><span class="line">#### JList、JComboBox实现列表框</span><br><span class="line">JList和JComboBox极其相似，他们都只有一个列表框，只是JComboBox的列表框需要以下拉方式显示出来；JList和JComboBox都可以通过setRenderer()方法来改变列表项的表现形式。甚至维护这两个组件的Model都是相似的，JList使用ListModel,JComboBox使用JComboBoxModel，而ComboBoxModel是ListModel的子类。</span><br><span class="line"></span><br><span class="line">1.简单列表框</span><br><span class="line">使用JList或JComboBox实现简单列表框的步骤：</span><br><span class="line"></span><br><span class="line">1.1创建JList或JComboBox对象</span><br><span class="line">JList(final E[] listData)：创建JList对象，把listData数组中的每项内容转换成一个列表项展示</span><br><span class="line">JList(final Vector&lt;? extends E&gt; listData)：创建JList对象，把listData数组中的每项内容转换成一个列表项展示</span><br><span class="line">JComboBox(E[] items)</span><br><span class="line">JComboBox(Vector&lt;E&gt; items)</span><br><span class="line"></span><br><span class="line">1.2设置JList或JComboBox的外观行为</span><br><span class="line">详见API</span><br><span class="line"></span><br><span class="line">1.3设置监听器</span><br><span class="line">JList通过addListSelectionListener完成，JComboBox通过addItemListener完成 </span><br><span class="line"></span><br><span class="line">##### 不强制储存列表项的ListModel和ComboBoxModel</span><br><span class="line">JList和JComboBox只负责外观的展示，而组件底层的状态数据则由相对应的Model来维护</span><br><span class="line"></span><br><span class="line">##### 强制存储列表项的DefaultListModel和DefaultComboBoxModel</span><br><span class="line"></span><br><span class="line">DefaultListModel提供的方法：</span><br><span class="line"></span><br><span class="line">add(int index, E element)</span><br><span class="line"></span><br><span class="line">addElement(E obj)</span><br><span class="line"></span><br><span class="line">insertElementAt(E obj,int index)</span><br><span class="line"></span><br><span class="line">remove(int index)</span><br><span class="line"></span><br><span class="line">removeAllElements()</span><br><span class="line"></span><br><span class="line">removeElement(E element)</span><br><span class="line"></span><br><span class="line">removeElementAt(int index)</span><br><span class="line"></span><br><span class="line">removeRange(int fromIndex,int toIndex)</span><br><span class="line"></span><br><span class="line">set(int index,E element)</span><br><span class="line"></span><br><span class="line">setElementAt(E obj,int index)</span><br><span class="line"></span><br><span class="line">##### 使用ListCellRenderer改变列表外观</span><br><span class="line"></span><br><span class="line">实际上，JList和JComboBox还可以支持图标列表项，如果在创建JList或者JComboBox时传入图标数组，则创建的JList和JComboBox的列表项就是图标。</span><br><span class="line"></span><br><span class="line">如果希望列表项是更复杂的组件，例如希望像QQ一样每个列表既有图标又有字符串，此时需要使用ListCellRenderer接口的实现类对象，自定义每个条目组件的渲染过程。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">public interface ListCellRenderer&lt;E&gt; &#123;</span><br><span class="line">	Component getListCellRendererComponent(</span><br><span class="line">	JList&lt;? extends E&gt; list,&#x2F;&#x2F;列表组件</span><br><span class="line">    E value,&#x2F;&#x2F;当前列表项的内容</span><br><span class="line">    int index,&#x2F;&#x2F;当前列表项的索引</span><br><span class="line">    boolean isSelected,&#x2F;&#x2F;当前列表项是否被选中</span><br><span class="line">    boolean cellHasFocus);&#x2F;&#x2F;当前列表项是否获取了焦点</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>通过JList的setCellRenderer(ListCellRenderer&lt;? super E&gt;cellRenderer)方法，把自定义的ListCellRenderer对象传递给JList，就可以按照自定义的规则来绘制列表项组件了。</p>
<p>绘制组件大小：setPreferredSize()</p>
<h4 id="JTree、TreeModel实现树"><a href="#JTree、TreeModel实现树" class="headerlink" title="JTree、TreeModel实现树"></a>JTree、TreeModel实现树</h4><p>树也是图形化用户界面中使用广泛的GUI组件，例如使用Windows资源管理器时，将看到如下图所示的目录树</p>
<p><img src="C:\Users\15135\AppData\Roaming\Typora\typora-user-images\image-20211116202753477.png" alt="image-20211116202753477"></p>
<p>按照结点是否包含子节点，可以把结点分为下面两类：</p>
<p>普通节点：包含子节点的结点；</p>
<p>叶子节点：没有子节点的结点；</p>
<p>按照结点是否具有唯一的父节点，可以把结点分为下面两类：</p>
<p>根节点：没有父节点的结点，计算机中，一棵树只能有一个根节点</p>
<p>普通节点：具有唯一父节点的结点</p>
<h5 id="创建树"><a href="#创建树" class="headerlink" title="创建树"></a>创建树</h5><p>当一个结点具有子节点时，该节点有两种状态：</p>
<p>展开状态：当父节点处于展开状态时，其子节点是可见的；</p>
<p>折叠状态：当父节点属于折叠状态时，其子节点都是不可见的；</p>
<h5 id="JTree常用构造方法"><a href="#JTree常用构造方法" class="headerlink" title="JTree常用构造方法"></a>JTree常用构造方法</h5><p>JTree(TreeModel newModel)：使用指定的数据模型来创建JTree对象，它默认显示根节点。</p>
<p>JTree(TreeNode root)：使用root作为根节点创建JTree对象，它默认显示根节点。</p>
<p>JTree(TreeNode root,boolean askAllowsChildren)：使用root作为根节点创建JTree对象，它默认显示根节点，其他详见API。</p>
<p>TreeNode继承体系及使用：</p>
<p>接口：TreeNode-&gt;接口：MutableTreeNode-&gt;DefaultMutableTreeNode；</p>
<p>JTree的其他外观设置方法：</p>
<p>tree.putClientProperty(“JTree.lineStyle”,”None”)：设置结点之间没有连接线</p>
<p>tree.putClientProperty(“JTree.lineStyle”,”Horizontal”)：设置结点之间只有水平分割线</p>
<h5 id="DefaultMutableTreeNode其他的成员方法"><a href="#DefaultMutableTreeNode其他的成员方法" class="headerlink" title="DefaultMutableTreeNode其他的成员方法"></a>DefaultMutableTreeNode其他的成员方法</h5><p>获取下一个兄弟结点</p>
<p>getNextSibling();</p>
<p>获取父节点</p>
<p>getParent();</p>
<p>判断是否为叶子结点</p>
<p>isLeaf();</p>
<p>判断是否为根节点</p>
<p>isRoot();</p>
<p>详见API</p>
<h4 id="编辑树节点"><a href="#编辑树节点" class="headerlink" title="编辑树节点"></a>编辑树节点</h4><p>JTree生成的树默认是不可编辑的，调用JTree的setEditable(boolean b)方法可使JTree对象变成可编辑状态</p>
<h5 id="编辑树节点的步骤"><a href="#编辑树节点的步骤" class="headerlink" title="编辑树节点的步骤"></a>编辑树节点的步骤</h5><p>1.获取被选中的结点</p>
<p>获取当前被选中的结点，会有两种方式：</p>
<p>一：</p>
<p>通过JTree对象的某些方法，例如：TreePath getSelectionPath()等，得到一个TreePath对象，包含了从根节点到当前结点路径上的所有结点</p>
<p>调用TreePath对象的 Object GetlastPathComponent() 方法，得到当前选中结点</p>
<p>二：</p>
<p>调用TreePath对象的 Object GetlastPathComponent() 方法，得到当前选中结点</p>
<p>2.调用DefaultModel数据模型有关增删改查的一系列方法完成编辑，方法执行后，<strong>重绘Tree</strong></p>
<h4 id="监听结点事件"><a href="#监听结点事件" class="headerlink" title="监听结点事件"></a>监听结点事件</h4><h5 id="为JTree添加监听器："><a href="#为JTree添加监听器：" class="headerlink" title="为JTree添加监听器："></a>为JTree添加监听器：</h5><p>1.addTreeExpansionListener(TreeExpansionListener tel)：添加树结点展开折叠事件的监听器</p>
<p>2.addTreeSelectionListener(TreeSelectionListener tsl)：添加树节点选择事件的监听器</p>
<h5 id="修改JTree的选择模式："><a href="#修改JTree的选择模式：" class="headerlink" title="修改JTree的选择模式："></a>修改JTree的选择模式：</h5><p>JTree专门提供了一个TreeSelectionModel对象来保存该JTree选中状态的信息。也就是说，JTree组件背后隐藏了两个model对象，其中TreeModel用于保存该JTree所有的节点数据，而TreeSelectionModel用于保存在JTree的所有选中状态的信息。</p>
<p>程序可以改变JTree的选择模式，但必须先获取该JTree对应的TreeSelectionModel对象，再调用该对象的setSelectionModel(int mode);方法来设置该JTree的选择模式，其中model可以有如下三种取值：</p>
<p>1.TreeSelectionModel.CONTIGUOUS_TREE_SELECTION：可以连续选中多个TreePath。</p>
<p>2.TreeSelectionModel.DISCONTIGUOUS_TREE_SELECTION：该选项对于选择没有任何限制。</p>
<p>3.TreeSelectionModel.SINGLE_TREE_SELECTION：每次只能选择一个TreePath。</p>
<h4 id="使用DefaultTreeCellRenderer改变结点外观"><a href="#使用DefaultTreeCellRenderer改变结点外观" class="headerlink" title="使用DefaultTreeCellRenderer改变结点外观"></a>使用DefaultTreeCellRenderer改变结点外观</h4><p>JTree默认的外观是比较单一的，但它提供了如下几种改变结点外观的方式：</p>
<p>1.使用DefaultTreeCellRenderer直接改变结点的外观，这种方式可以改变整棵树所有结点的字体、颜色和图标。</p>
<p>2.为JTree指定DefaultTreeCellRenderer 的拓展类对象作为 JTree 的结点绘制器，该绘制器负责为不同结点使用不同的字体、颜色和图标。这种方法较为常用。</p>
<p>3.为JTree指定一个实现 TreeCellRenderder 接口的节点绘制器，改绘制器可以为不同节点自由绘制任意内容，这是最复杂但是最灵活的节点绘制器。</p>
<p>DefaultTreeCellRenderer 提供了如下几个方法来修改节点的外观：</p>
<p>详见</p>
<h3 id="JTable、TableModel实现表格"><a href="#JTable、TableModel实现表格" class="headerlink" title="JTable、TableModel实现表格"></a>JTable、TableModel实现表格</h3><p>表格也是GUI程序中常用的组件，表格是一个由多行、多列组成的二维显示区</p>
<h4 id="创建简单表格"><a href="#创建简单表格" class="headerlink" title="创建简单表格"></a>创建简单表格</h4><h5 id="使用JTable创建简单表格步骤："><a href="#使用JTable创建简单表格步骤：" class="headerlink" title="使用JTable创建简单表格步骤："></a>使用JTable创建简单表格步骤：</h5><p>1.创建一个一维数组，存储表格中每一列的标题</p>
<p>2.创建一个二维数组，存储表格中每一行数据</p>
<p>3.根据第一步和第二部创建的一维数组和二维数组，创建JTable对象</p>
<p>4.把JTable添加到其他容器中显示</p>
<h5 id="JTable调整列宽"><a href="#JTable调整列宽" class="headerlink" title="JTable调整列宽"></a>JTable调整列宽</h5><p>JTable使用TableColumn来表示表格中的每一列，JTable中表格列的所有属性，如最佳宽度、是否可调整宽度、最小和最大宽度等都保存在该TableColumn中。</p>
<p>1.setMaxWidth(int maxWidth)：设置该行最大列宽，如果指定的maxWidth小于该列的最小宽度，则maxWidth被设置为最小宽度。</p>
<p>2.setMinWidth(int minWidth)：设置该列的最小宽度。</p>
<p>3.setPreferredWidth(int preferredWidth)：设置该列的最佳宽度。</p>
<h5 id="JTable调整表格选择模式："><a href="#JTable调整表格选择模式：" class="headerlink" title="JTable调整表格选择模式："></a>JTable调整表格选择模式：</h5><p>与JList类似的是，JTable使用了一个ListSelectionModel表示该表格的选择状态，程序可以通过ListSelectionModel.setSelectionModel(int mode)控制JTable的选择模式。JTable的选择模式有如下三种：</p>
<p>1.ListSelectionModel.MULTIPLE_INTERVAL_SELECTION：没有任何限制</p>
<p>2.ListSelectionModel.SINGLE_INTERVAL_SELECTION：选择单个连续区域</p>
<p>1.ListSelectionModel.SINGLE_SELECTION：只能选择单行</p>
<h4 id="TableModel"><a href="#TableModel" class="headerlink" title="TableModel"></a>TableModel</h4><p>与JList、JTree类似的是，JTable采用了 TableModel 来保存表格中所有状态数据：与ListModel类似的是，TableModel也不强制保存该表格显示的数据。虽然在前面程序中看到的是直接利用一个二维数组来创建JTable对象，但也可以通过TableModel 对象来创建表格</p>
<h5 id="自定义TableModel步骤："><a href="#自定义TableModel步骤：" class="headerlink" title="自定义TableModel步骤："></a>自定义TableModel步骤：</h5><p>1.自定义类，继承AbstractTableModel抽象类，重写下面几个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getColumnCount</span><span class="params">()</span><span class="comment">//返回表格列的数量</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getRowCount</span><span class="params">()</span><span class="comment">//返回表格行的数量</span></span></span><br><span class="line"><span class="function">Object <span class="title">getValueAt</span><span class="params">(<span class="keyword">int</span> rowIndex, <span class="keyword">int</span> columnIndex)</span><span class="comment">//返回rowIndex行，column列的单元格的值</span></span></span><br><span class="line"><span class="function">String <span class="title">getColumnName</span><span class="params">(<span class="keyword">int</span> columnIndex)</span><span class="comment">//返回columnIndex列的列名称</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isCellEditable</span><span class="params">(<span class="keyword">int</span> rowIndex,<span class="keyword">int</span> columnIndex)</span><span class="comment">//设置rowIndex行，columnIndex列单元格是否可编辑</span></span></span><br></pre></td></tr></table></figure>

<p>2.创建自定义类对象，根据该对象，创建JTable对象</p>
<h5 id="DefaultTableModel"><a href="#DefaultTableModel" class="headerlink" title="DefaultTableModel"></a>DefaultTableModel</h5><p>Swing本身为AbstractTableModel提供了一个DefaultTableModel实现类，程序可以通过使用DefaultTableModel实现类来创建JTable对象。通过DefaultTableModel对象创建JTable对象后，就可以调用它提供的方法来添加数据行、插入数据行、删除数据行和移动数据行。DefaultTableModel提供了如下几个方法来控制数据行操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">addColumn(Object columnName)/addColumn(Object columnName, Object[] columnData)<span class="comment">//添加一列/添加一列并加入数据</span></span><br><span class="line">addRow(Object[] rowData)<span class="comment">//添加一行</span></span><br><span class="line">insertRow(<span class="keyword">int</span> row, Object[] rowData)<span class="comment">//指定位置插入一行</span></span><br><span class="line">removeRow(<span class="keyword">int</span> row)<span class="comment">//删除一行</span></span><br><span class="line">moveRow(<span class="keyword">int</span> start, <span class="keyword">int</span> end, in to)<span class="comment">//移动指定范围内的数据行</span></span><br></pre></td></tr></table></figure>

<p>Swing杀青</p>
<h1 id="Java-I-O流"><a href="#Java-I-O流" class="headerlink" title="Java I/O流"></a>Java I/O流</h1><h2 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h2><p>File(String pathName)<br>通过指定的路径名字符串转换为抽象路径名来创建新的File实例<br>File(String parent,String child)<br>从父路径名字符串和子路径名字符串创建新的File实例<br>File(File parent,String child)<br>从父抽象路径名和子路径名字符串创建新的File实例</p>
<h3 id="File类中常用方法"><a href="#File类中常用方法" class="headerlink" title="File类中常用方法"></a>File类中常用方法</h3><h4 id="File类创建功能"><a href="#File类创建功能" class="headerlink" title="File类创建功能"></a>File类创建功能</h4><p>createNewFile()：当具有该名称的文件不存在时，创建一个由该抽象路径名命名的新空文件<br>mkdir()：闯将由此抽象路径命名的目录<br>mkdirs()：创建由此抽象路径命名的目录，包括任何必须但不存在的父目录</p>
<h4 id="File类判断和获取功能"><a href="#File类判断和获取功能" class="headerlink" title="File类判断和获取功能"></a>File类判断和获取功能</h4><p>isDirectory()：测试此抽象路径名表示的File是否为目录<br>isFile()：测试此抽象路径名表示的File是否为文件<br>exist()：判断File对象指向的文件是否存在，返回一个boolean类型的值。<br>getAbsolutePath()：返回此抽象路径名的绝对路径名字符串<br>getPath()：将此抽象路径名转换为路径名字符串<br>getName()：返回由此路径名表示的文件或目录的名称<br>list()：返回此抽象路径名表示的目录中的文件和目录的名称字符串数组<br>listFiles()：返回此抽象路径名表示的目录中的文件和目录的File对象数组</p>
<h4 id="File类删除功能"><a href="#File类删除功能" class="headerlink" title="File类删除功能"></a>File类删除功能</h4><p>delete()：删除由此抽象路径名表示的文件或目录</p>
<h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><h4 id="IO流概述："><a href="#IO流概述：" class="headerlink" title="IO流概述："></a>IO流概述：</h4><p>IO：输入输出（Input/Output）<br>流：是一种抽象概念，是对数据传输的总称。也就是说数据在设备间的传输称为流，流的本质是数据传输<br>IO流就是用来处理设备间传输问题的<br>常见应用：文件复制，文件上传，文件下载</p>
<h4 id="IO分类"><a href="#IO分类" class="headerlink" title="IO分类"></a>IO分类</h4><p>按照数据的流向<br>输入流：读数据<br>输出流：写数据</p>
<p>按照数据类型来分<br>字节流：字节输入/输出流<br>字符流：字符输入/输出流<br>用记事本打开字符流读得懂，字符流读不懂</p>
<h4 id="字节流写数据"><a href="#字节流写数据" class="headerlink" title="字节流写数据"></a>字节流写数据</h4><p>字节流抽象基类<br>InputStream：这个抽象类是表示字节输入流的所有类的超类<br>OutputStream：这个抽象类是表示字节输出流的所有超类<br>子类名特点：子类名称都是以其父类名作为子类名的后缀</p>
<hr>
<p>FileOutputStream：文件输入流用于将数据写入File<br>FileOutputStream(String name)：创建文件输出流以指定的名称写入文件</p>
<h5 id="输入流方法："><a href="#输入流方法：" class="headerlink" title="输入流方法："></a>输入流方法：</h5><p>void write(int b)：将指定的字节写入此文件输出流<br>最后都要释放资源<br>void close()：关闭此文件输出流并释放与此流相关联的任何系统资源<br>使用字节输出流写数据的步骤：<br>1.创建字节输出流对象（调用系统功能创建了文件，创建字节输出流对象，让字节输出流对象指向文件）<br>2.调用字节输出流对象的写数据方法<br>3.释放资源（关闭此文件输出流并释放与此流相关联的任何系统资源）</p>
<p>所有有关IO的操作必须关闭</p>
<hr>
<h5 id="字节流写数据的3种方式"><a href="#字节流写数据的3种方式" class="headerlink" title="字节流写数据的3种方式"></a>字节流写数据的3种方式</h5><p>void write(int b)：将指定的字节写入此文件输出流，一次写一个字节数据<br>void write(byte[] b)：将b.length字节从指定的字节数组写入此文件输出流，一次写一个字节数据<br>void write(byte[] b,int off,int len)：将len字节从指定的字节数组开始，从偏移量off开始写入此文件输出流，一次写一个字节数组的部分数据</p>
<p>FileOutputStream fos = new FileOutputStream(“1.txt”) 等价于 FileOutputStream fos = new FileOutputStream(new File(“1.txt”))</p>
<p>byte[] getByte() 返回字符串对应的字节数组</p>
<h5 id="字节流写数据的两个小问题"><a href="#字节流写数据的两个小问题" class="headerlink" title="字节流写数据的两个小问题"></a>字节流写数据的两个小问题</h5><p>1.字节流写数据如何实现换行？<br>windows：\r\n<br>linux：\n<br>mac：\r<br>2.字节流写数据如何实现追加写入？</p>
<p>public FileOutputStream(String name,boolean append)</p>
<p>创建文件输出流以指定的名称写入文件</p>
<p>如果第二个参数为true，则字节将写入文件的末尾而不是开头</p>
<h5 id="字节流写数据加异常处理"><a href="#字节流写数据加异常处理" class="headerlink" title="字节流写数据加异常处理"></a>字节流写数据加异常处理</h5><p>finally：在异常处理时提供finally块来执行所有清除操作，比如IO中的释放资源</p>
<p>try {</p>
<p>​    可能出现异常的代码</p>
<p>} catch 异常类名 变量名 {</p>
<p>​    异常的处理代码</p>
<p>} finally {</p>
<p>​    执行所有清除操作</p>
<p>}</p>
<p>JDK7改进方案：</p>
<p>try(定义流对象) {</p>
<p>​    可能出现异常的代码</p>
<p>} catch(异常类名 变量名) {</p>
<p>​    异常的处理代码</p>
<p>}</p>
<p>自动释放资源</p>
<p>JDK9改进方案：</p>
<p>定义输入流对象：</p>
<p>定义输出流对象：</p>
<p>try(输入流对象;输出流对象) {</p>
<p>​    可能出现异常的代码</p>
<p>} catch(异常类名 变量名) {</p>
<p>​    异常的处理代码</p>
<p>}</p>
<p>自动释放资源</p>
<h4 id="字节流读数据"><a href="#字节流读数据" class="headerlink" title="字节流读数据"></a>字节流读数据</h4><h5 id="字节流读数据（一次读一个字节数据）"><a href="#字节流读数据（一次读一个字节数据）" class="headerlink" title="字节流读数据（一次读一个字节数据）"></a>字节流读数据（一次读一个字节数据）</h5><p>FIleInputStream：从文件系统中的文件获取输入字节</p>
<p>FileInputStream(String name)：通过打开与实际文件的连接来创建一个FileInputStream，该文件由文件系统中的路径名name命名。</p>
<p>使用字节流读取数据的步骤：</p>
<p>1.创建字节输入流对象</p>
<p>2.调用字节输入流对象的读数据方法</p>
<p>3.释放资源</p>
<p>int read()：从输入流读取一个字节的数据</p>
<p>数据的下一个字节，如果达到文件的末尾，值为-1</p>
<p>遍历文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(File file);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> read = fis.read();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(read != -<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">​	System.out.print((<span class="keyword">char</span>)read);</span><br><span class="line"></span><br><span class="line">​	read = fis.read();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">优化以上代码</span><br><span class="line"><span class="keyword">int</span> by;</span><br><span class="line"><span class="keyword">while</span>((by = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">  System.out.println((<span class="keyword">char</span>)by);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="字节流案例：复制文本文件"><a href="#字节流案例：复制文本文件" class="headerlink" title="字节流案例：复制文本文件"></a>字节流案例：复制文本文件</h5><p>分析：</p>
<p>1.其实就是把文本内容从一个文件中读取出来（数据源），然后写入到另一个文件中（目的地）</p>
<p>2.数据源：</p>
<p>​    1.txt—读数据—InputStream—FileInputStream</p>
<p>3.目的地：</p>
<p>​    D:\\1.txt—写数据—OutputStream—FileOutputStream</p>
<h5 id="字节流读数据（一次一个字节数组数据）"><a href="#字节流读数据（一次一个字节数组数据）" class="headerlink" title="字节流读数据（一次一个字节数组数据）"></a>字节流读数据（一次一个字节数组数据）</h5><p>int read(byte[] b)：从该输入流读取最多b.length个字节的数据到一个字节数组</p>
<p>String (byte[] bytes,int offset,int length)</p>
<p>数据的下一个字节，如果达到文件的末尾，值为-1</p>
<h5 id="字节流案例：复制图片"><a href="#字节流案例：复制图片" class="headerlink" title="字节流案例：复制图片"></a>字节流案例：复制图片</h5><p>分析：</p>
<p>1.根据数据源创建字节输入流对象</p>
<p>2.根据目的地创建字节输出流对象</p>
<p>3.读写数据，复制图片（一次读取一个字节数组，一次写入一个字节数组）</p>
<p>4.释放资源</p>
<h4 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h4><p>BufferedOutputStream：该类实现缓冲输出流。通过设置这样的输出流，应用程序可以向底层输出流写入字节，而不必为写入的每个字节导致底层系统的调用</p>
<p>BufferedInputStream：创建BufferedInputStream将创建一个内部缓冲数组。当从流中读取或跳过字节时，内部缓冲区将根据需要从所包含的输入流中重新填充，一次很多字节。</p>
<hr>
<p>构造方法：</p>
<p>字节缓冲输出流：BufferedOutputStream(OutputStream out)</p>
<p>字节缓冲输入流：BufferedInputStream(InputStream in)</p>
<p>question：为什么构造方法需要的是字节流，而不是具体的文件或者路径呢？</p>
<p>answer：字节缓冲流仅仅提供缓冲区，而真正的读写数据还是得依靠基本得字节流对象进行操作</p>
<h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><p>tips：为什么会出现字符流</p>
<p>一个汉字存储：</p>
<p>如果是GBK编码，占用两个字节</p>
<p>如果是UTF-8编码，占用三个字节</p>
<p>getBytes(charName name);</p>
<p>字符流 = 字节流 + 编码表</p>
<p>tips：如何识别中文？</p>
<p>汉字在存储的时候，无论选择哪种编码存储，第一个字节都是负数</p>
<h5 id="编码表"><a href="#编码表" class="headerlink" title="编码表"></a>编码表</h5><p>基础知识：计算机中储存的信息都是二进制数表示的</p>
<p>按照某种规则，将字符存储到计算机中，称为编码。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为解码。按A方式编码储存就必须按A方式编码解析</p>
<p>字符编码：就是一套自然语言的字符与二进制数之间的对应规则</p>
<p>字符集：</p>
<p>是一个系统所支持的所有字符的集合，包括各国文字、标点符号、图形符号、数字等</p>
<p>计算机要准确的存储和识别各种字符集符号，就需要进行字符编码，一套字符集必然至少有一套字符编码。常见的字符集有ASCII字符集、GBXXX字符集、Unicode字符集</p>
<h5 id="字符串中的编码解码问题"><a href="#字符串中的编码解码问题" class="headerlink" title="字符串中的编码解码问题"></a>字符串中的编码解码问题</h5><p>编码：</p>
<p>byte[] getBytes()：使用平台的默认字符集将该String编码为一系列字节，将结果存储到新的字节数组中</p>
<p>byte[] getBytes(String charsetName)：使用指定的字符集将该String编码为一系列字节，将结果存储到新的字节数组中</p>
<p>解码：</p>
<p>String(byte[] bytes)：通过使用平台的默认字符集解码指定的字节数组来构造新的String</p>
<p>String(byte[] bytes,String charsetName)：通过指定的字符集解码指定的字节数组来构造新的String</p>
<h4 id="字符流抽象基类"><a href="#字符流抽象基类" class="headerlink" title="字符流抽象基类"></a>字符流抽象基类</h4><p>Reader：字符输入流的抽象类</p>
<p>Writer：字符输出流的抽象类</p>
<p>字符流中编码和解码相关的两个类：</p>
<p>InputSteamReader</p>
<p>OutputStreamWriter</p>
<h5 id="OutputStreamWriter字符流写数据的五种方式"><a href="#OutputStreamWriter字符流写数据的五种方式" class="headerlink" title="OutputStreamWriter字符流写数据的五种方式"></a>OutputStreamWriter字符流写数据的五种方式</h5><p>一次写一个字符</p>
<p>write(char c);</p>
<p>一次写一个数组</p>
<p>write(char[] chs)</p>
<p>一次写入一个数组的一部分</p>
<p>write(char[] chs,off,length)</p>
<p>一次写一个字符串</p>
<p>write(String str)</p>
<p>一次写一个字符串的一部分</p>
<p>write(String str,off,length)</p>
<p>字符流刷新方法</p>
<p>flush() 还可继续写数据</p>
<p>close() 关闭流，释放资源，但是在关闭前会先刷新流，一旦关闭就不能写数据</p>
<p>Tips：字符流相当于字节流有缓冲，主要还是通过FileOutputStream写数据，记得要用flush()刷新，close()在关闭前也会刷新。</p>
<h5 id="InputStreamReader读数据的两种方式"><a href="#InputStreamReader读数据的两种方式" class="headerlink" title="InputStreamReader读数据的两种方式"></a>InputStreamReader读数据的两种方式</h5><p>int read() 一次读一个字符数据</p>
<p>int read(char[] chs) 一次读一个字符数组</p>
<h4 id="FileReader和FileWriter"><a href="#FileReader和FileWriter" class="headerlink" title="FileReader和FileWriter"></a>FileReader和FileWriter</h4><p>FileReader：用于读取字符文件的便携类</p>
<p>FileReader(String fileName)</p>
<p>FileWriter：用于写入字符文件的便携类</p>
<p>FileWriter(String fileName)</p>
<h4 id="字符缓冲流BufferedReader和BufferedWriter"><a href="#字符缓冲流BufferedReader和BufferedWriter" class="headerlink" title="字符缓冲流BufferedReader和BufferedWriter"></a>字符缓冲流BufferedReader和BufferedWriter</h4><p>BufferedWriter：将文本写入字符输出流，缓冲字符，以提供单个字符，数组和字符串的高效写入，可以指定缓冲区大小，或者可以接受默认大小。默认值足够大，可用于大多数用途</p>
<p>BufferedReader：从字符输出流读取文本，缓冲字符，以提供字符，数组和行的高效读取，可以指定缓冲区大小，或者可以使用默认大小。默认值足够大，可用于大多数用途</p>
<h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><p>BufferWriter(Writer out)</p>
<p>BufferReader(Reader in)</p>
<h5 id="字符缓冲流的特有功能"><a href="#字符缓冲流的特有功能" class="headerlink" title="字符缓冲流的特有功能"></a>字符缓冲流的特有功能</h5><p>BufferedWriter：</p>
<p>void newLine()：写一行分隔符，行分隔符字符串由系统属性定义</p>
<p>BufferedReader：</p>
<p>public String readLine()：读一行文字，结果包含行的内容的字符串，不包括任何终止字符，如果流的结尾已经到达，则为null</p>
<h3 id="IO流小结"><a href="#IO流小结" class="headerlink" title="IO流小结"></a>IO流小结</h3><p><img src="C:\Users\15135\AppData\Roaming\Typora\typora-user-images\image-20211105095548418.png" alt="image-20211105095548418"></p>
<p><img src="C:\Users\15135\AppData\Roaming\Typora\typora-user-images\image-20211105095734136.png" alt="image-20211105095734136"></p>
<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><h5 id="复制多级文件夹"><a href="#复制多级文件夹" class="headerlink" title="复制多级文件夹"></a>复制多级文件夹</h5><p>需求：把“E:\itcast” 复制到D盘目录下</p>
<hr>
<p>思路：</p>
<p>1.创建数据源File对象，路径是D:\\itcast</p>
<p>2.创建目的地File对象，路径是D:\\</p>
<p>3.写方法实现文件夹的复制，参数为数据源File对象和目的地File对象</p>
<p>4.判断数据源FIle是否是目录</p>
<p>​        是：</p>
<p>​                    A：在目的地下创建和数据源File名称一样的目录</p>
<p>​                    B：获取数据源File下所有文件或者目录的File数组</p>
<p>​                    C：遍历该File数组，得到每一个File对象</p>
<p>​                    D：把该File作为数据源File对象，递归调用复制文件夹的方法</p>
<p>​        不是：说明是文件，直接复制，用字节流</p>
<h3 id="特殊操作流"><a href="#特殊操作流" class="headerlink" title="特殊操作流"></a>特殊操作流</h3><h4 id="对象序列化流"><a href="#对象序列化流" class="headerlink" title="对象序列化流"></a>对象序列化流</h4><p>对象序列化：就是将对象保存到磁盘中，或者在网络中传输对象</p>
<p>这种机制就是使用一个字节序列表示一个对象，该字节序列包含：对象的类型、对象的数据和对象中存储的属性等信息。字节序列写道文件后，相当于文件中持久保存了一个对象的信息</p>
<hr>
<p>要实现序列化和反序列化就要使用对象序列化流和对象反序列化流：</p>
<ul>
<li>对象序列化流：ObjectOutputStream<ul>
<li>将java对象的原始数据类型和图形写入OutputStream。可以使用ObjectInputStream读取（重构）对象。可以通过使用流的文件来实现对对象的持久存储。如果流是网络套接字流，则可以在另一个主机上或另一个进程中重构对象。</li>
<li>构造方法：ObjectOutputStream(OutputStream out)：创建一个写入指定的OutputStream的ObjectOutputStream</li>
<li>序列化对象的方法：void writeObject(Object obj)：将指定的对象写入ObjectOutputStream</li>
<li><strong>注意</strong>：<ul>
<li>一个对象想要被序列化，该对象所属的类必须实现Serializable接口</li>
<li>Serializable是一个标记接口，实现该接口，不需要重写任何方法</li>
</ul>
</li>
</ul>
</li>
<li>对象反序列化流：ObjectInputStream<ul>
<li>ObjectInputStream反序列化前先使用ObjectOutputStream编写的原始数据和对象</li>
<li>构造方法：ObjectInputStream(InputStream in)：创建从指定的InputStream读取的ObjectInputStream</li>
<li>反序列化的方法：Object readObject()：从ObjectInputStream读取一个对象</li>
</ul>
</li>
</ul>
<h5 id="序列化中存在的问题"><a href="#序列化中存在的问题" class="headerlink" title="序列化中存在的问题"></a>序列化中存在的问题</h5><p>用对象序列化流序列化了一个对象后，假如我们修改了对象所属的类文件，读取数据会不会出问题呢？</p>
<ul>
<li>会出问题，抛出InvalidClassException异常</li>
</ul>
<p>2.如果出问题了，如何解决呢？</p>
<ul>
<li>给对象所属的类加一个serialVersionUID<ul>
<li>private static final serialVersionUID = 42L;</li>
</ul>
</li>
</ul>
<p>3.如果对象中某个成员不想被序列化，又该如何实现呢？</p>
<ul>
<li>给该成员变量加transient关键字修饰，该关键字标记的成员变量不参与序列化过程</li>
</ul>
<h4 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h4><h5 id="Properties概述："><a href="#Properties概述：" class="headerlink" title="Properties概述："></a>Properties概述：</h5><ul>
<li>是一个Map体系的集合类</li>
<li>Properties可以保存到流中或从流中加载</li>
</ul>
<h5 id="Properties作为集合的特有方法："><a href="#Properties作为集合的特有方法：" class="headerlink" title="Properties作为集合的特有方法："></a>Properties作为集合的特有方法：</h5><ul>
<li><p>Object setProperty(String key, String value) ：设置集合的键和值，都是String类型，底层调用Hashtable方法put</p>
</li>
<li><p>String getProperty(String key)：使用此属性列表中指定的键搜索属性</p>
</li>
<li><p>Set<String> stringPropertyNames()：从该属性列表中返回一个不可修改的键集，其中键及其对应的值是字符串</p>
</li>
<li><p>```java</p>
<pre><code>public static void main(String[] args) &#123;
</code></pre>
<p>//        创建集合对象</p>
<pre><code>    Properties prop = new Properties();
</code></pre>
<p>//        设置集合的键和值</p>
<pre><code>    prop.setProperty(&quot;itheima001&quot;,&quot;林青霞&quot;);
    prop.setProperty(&quot;itheima002&quot;,&quot;张曼玉&quot;);
    prop.setProperty(&quot;itheima003&quot;,&quot;王祖贤&quot;);
</code></pre>
<p>//        搜索属性</p>
<pre><code>    System.out.println(prop.get(&quot;itheima001&quot;));

    Set&lt;String&gt; names = prop.stringPropertyNames();
    for(String key : names) &#123;
</code></pre>
<p>//            System.out.println(key);</p>
<pre><code>        System.out.println(prop.get(key));
    &#125;
&#125;
</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### Properties和IO流集合的方法：</span><br><span class="line"></span><br><span class="line">* void load(InputStream in)：从输入字节流读取属性列表（键和元素对）</span><br><span class="line">* void load(Reader reader)：从输入字符流读取属性列表（键和元素对）</span><br><span class="line">* void store(OutputStream out, String comments)：将此属性列表（键和元素对）写入此Properties表中，以适合于使用load(InputStream)方法的格式写入输出字节流</span><br><span class="line">* void store(Writer writer, String comments)：将此属性列表（键和元素对）写入此Properties表中，以适合于使用load(Reader)方法的格式写入输出字符流</span><br><span class="line"></span><br><span class="line">## 实现多线程</span><br><span class="line"></span><br><span class="line">#### 1.1进程</span><br><span class="line"></span><br><span class="line">##### 进程：是正在运行的程序</span><br><span class="line"></span><br><span class="line">* 是系统进行资源分配和调用的独立单位</span><br><span class="line"></span><br><span class="line">### 1.2线程</span><br><span class="line"></span><br><span class="line">##### 线程：是进程中的单个顺序控制流，是一条执行路径</span><br><span class="line"></span><br><span class="line">* 单线程：一个进程如果只有一条执行路径，则称为单线程程序</span><br><span class="line">* 多线程：一个进程如果有多条执行路径，则称为多线程程序</span><br><span class="line"></span><br><span class="line">##### 举例：</span><br><span class="line"></span><br><span class="line">* 记事本案例：单线程程序</span><br><span class="line">* 扫雷程序：多线程程序</span><br><span class="line"></span><br><span class="line">### 1.3多线程的实现方式</span><br><span class="line"></span><br><span class="line">##### 方式1：继承Thread类</span><br><span class="line"></span><br><span class="line">* 定义一个类MyThread继承Thread类</span><br><span class="line">* 在MyThread类中重写run()方法</span><br><span class="line">* 创建MyThread类的对象</span><br><span class="line">* 启动线程：start()方法</span><br><span class="line"></span><br><span class="line">##### 方式2：实现Runnable接口</span><br><span class="line"></span><br><span class="line">* 定义一个类MyRunnable实现Runnable接口</span><br><span class="line"></span><br><span class="line">* 在MyRunnable类中重写run()方法</span><br><span class="line"></span><br><span class="line">* 创建MyRunnable类的对象</span><br><span class="line"></span><br><span class="line">* 创建Thread类的对象，把MyRunnable对象作为构造方法的参数</span><br><span class="line"></span><br><span class="line">  * &#96;&#96;&#96;java</span><br><span class="line">    MyRunnable my &#x3D; new MyRunnable();&#x2F;&#x2F;创建MyRunnable类的对象</span><br><span class="line">    Thread t1 &#x3D; new Thread(my);&#x2F;&#x2F;Thread(Runnable target)</span><br><span class="line">    Thread t2 &#x3D; new Thread(my,&quot;线程1&quot;);&#x2F;&#x2F;Thread(Runnable target, String name)</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li>
<li><p>启动线程</p>
</li>
</ul>
<h5 id="相比继承Thread类，实现Runnable接口的好处"><a href="#相比继承Thread类，实现Runnable接口的好处" class="headerlink" title="相比继承Thread类，实现Runnable接口的好处"></a>相比继承Thread类，实现Runnable接口的好处</h5><ul>
<li>避免了Java单继承的局限性</li>
<li>适合多个相同程序的代码去处理同一个资源的情况，把线程和程序的代码、数据有效分离，较好的体现了面向对象的设计思想</li>
</ul>
<h5 id="两个小问题："><a href="#两个小问题：" class="headerlink" title="两个小问题："></a>两个小问题：</h5><ul>
<li>为什么要重写run()方法？<ul>
<li>因为run()是用来封装被线程执行的代码</li>
</ul>
</li>
<li>run()方法和start()方法的区别？<ul>
<li>run()：封装线程执行的代码，直接调用，相当于普通方法的调用</li>
<li>start()：启动线程，然后由JVM调用此线程的run()方法</li>
</ul>
</li>
</ul>
<h3 id="1-4设置和获取线程名称"><a href="#1-4设置和获取线程名称" class="headerlink" title="1.4设置和获取线程名称"></a>1.4设置和获取线程名称</h3><h5 id="Thread类中设置和获取线程名称的方法"><a href="#Thread类中设置和获取线程名称的方法" class="headerlink" title="Thread类中设置和获取线程名称的方法"></a>Thread类中设置和获取线程名称的方法</h5><ul>
<li><p>void setName(String name)：将此线程的名称更改为等于参数name</p>
</li>
<li><p>String getName()：返回此线程的名称</p>
</li>
<li><p>通过构造方法也可以设置线程名称</p>
<ul>
<li><p>```java</p>
<pre><code>public MyThread(String name) &#123;
    super(name);
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### 如何获取main()方法所在的线程名称？</span><br><span class="line"></span><br><span class="line">* public static Thread currentThread()：返回对当前正在执行的线程对象的引用</span><br><span class="line"></span><br><span class="line">### 1.5线程调度</span><br><span class="line"></span><br><span class="line">##### 线程有两种调度模型</span><br><span class="line"></span><br><span class="line">* 分时调度模型：所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间片</span><br><span class="line">* 抢占式调度模型：优先让优先级高的线程使用CPU，如果线程的优先级相同。那么会随机选择一个，优先级高的线程获取的CPU时间片相对多一些</span><br><span class="line">* Java使用的是抢占式调度模型</span><br><span class="line"></span><br><span class="line">##### Thread类中设置和获取线程优先级的方法</span><br><span class="line"></span><br><span class="line">* public final getPriority()：返回此线程的优先级</span><br><span class="line">* public final void setPriority(int newPriority)：更改此线程的优先级</span><br><span class="line">  * 线程默认优先级为：5，最高优先级为：10，最低优先级为：1（线程优先级只是表示线程获取CPU时间片的几率高，但是要在次数比较多，或者多次运行的时候才能看见你想要的效果）</span><br><span class="line"></span><br><span class="line">### 1.6线程控制</span><br><span class="line"></span><br><span class="line">* static void sleep(long millis)：使当前正在执行的程序停留（暂停执行）指定的毫秒数</span><br><span class="line">* void join()：等待这个线程死亡</span><br><span class="line">* void setDaemon(boolean on)：将此线程标记为守护线程，当运行的线程都是守护线程使，Java虚拟机将退出</span><br><span class="line"></span><br><span class="line">### 1.7线程生命周期</span><br><span class="line"></span><br><span class="line">![image-20220112205528398](C:\Users\15135\AppData\Roaming\Typora\typora-user-images\image-20220112205528398.png)</span><br><span class="line"></span><br><span class="line">### 卖票案例数据安全问题的解决</span><br><span class="line"></span><br><span class="line">#### 为什么会出现问题？</span><br><span class="line"></span><br><span class="line">* 是否是多线程环境</span><br><span class="line">* 是否有共享数据</span><br><span class="line">* 是否有多条语句操作共享数据</span><br><span class="line"></span><br><span class="line">#### 如何解决多线程安全问题？</span><br><span class="line"></span><br><span class="line">* 基本思想：让程序没有安全问题的环境</span><br><span class="line"></span><br><span class="line">#### 怎么实现？</span><br><span class="line"></span><br><span class="line">* 把多条语句操作共享数据的代码锁起来，让任意时刻只能有一个线程执行即可</span><br><span class="line"></span><br><span class="line">### 1.8同步代码块</span><br><span class="line"></span><br><span class="line">锁多条语句操作共享数据，可以使用同步代码块实现</span><br><span class="line"></span><br><span class="line">* 格式：</span><br><span class="line"></span><br><span class="line">  * &#96;&#96;&#96;java</span><br><span class="line">    synchronized(任意对象) &#123;</span><br><span class="line">        多条语句操作共享数据的代码</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>synchronized(任意对象)：就相当于给代码加锁了，任意对象就可以看成是一把锁</p>
</li>
</ul>
</li>
</ul>
<h4 id="同步的好处和弊端"><a href="#同步的好处和弊端" class="headerlink" title="同步的好处和弊端"></a>同步的好处和弊端</h4><ul>
<li>好处：解决了多线程的数据安全问题</li>
<li>弊端：当线程很多时，因为每个线程都会去判断同步上的锁，这是很耗费资源的，无形中会降低程序的运行效率</li>
</ul>
<h3 id="1-9同步方法"><a href="#1-9同步方法" class="headerlink" title="1.9同步方法"></a>1.9同步方法</h3><h5 id="同步方法：就是把synchronized关键字加到方法上"><a href="#同步方法：就是把synchronized关键字加到方法上" class="headerlink" title="同步方法：就是把synchronized关键字加到方法上"></a>同步方法：就是把synchronized关键字加到方法上</h5><ul>
<li>格式：修饰符 synchronized 返回值类型 方法名(方法参数) {}</li>
</ul>
<h5 id="同步方法的锁对象是什么呢？"><a href="#同步方法的锁对象是什么呢？" class="headerlink" title="同步方法的锁对象是什么呢？"></a>同步方法的锁对象是什么呢？</h5><ul>
<li>this</li>
</ul>
<h5 id="同步静态方法：就是把synchronized关键字加到静态方法上"><a href="#同步静态方法：就是把synchronized关键字加到静态方法上" class="headerlink" title="同步静态方法：就是把synchronized关键字加到静态方法上"></a>同步静态方法：就是把synchronized关键字加到静态方法上</h5><ul>
<li>格式：修饰符 static synchronized 返回值类型 方法名(方法参数) {}</li>
</ul>
<h5 id="同步静态方法的锁对象是什么呢？"><a href="#同步静态方法的锁对象是什么呢？" class="headerlink" title="同步静态方法的锁对象是什么呢？"></a>同步静态方法的锁对象是什么呢？</h5><ul>
<li>类名.class</li>
</ul>
<h3 id="1-10线程安全的类"><a href="#1-10线程安全的类" class="headerlink" title="1.10线程安全的类"></a>1.10线程安全的类</h3><h5 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h5><ul>
<li>线程安全，可变的字符序列</li>
<li>从JDK5开始，被StringBuilder替代。通常应该使用StringBuilder类，因为它支持所有相同的操作，但它更快，因为它不执行同步</li>
</ul>
<h5 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h5><ul>
<li>从Java2平台v1.2开始，该类改进了List接口，使其成为Java Collections FrameWork的成员。与新的集合实现不同，Vector被同步。如果不需要线程安全的实现，建议使用ArrayList代替Vector</li>
</ul>
<h5 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h5><ul>
<li>该类实现了一个哈希表，它将键映射到值。任何非null对象都可以用作键或值</li>
<li>从Java平台v1.2开始，该类进行了改进，实现了Map接口，使其成为Java Collections FrameWork的成员。与新的集合实现不同，Hashtable 被同步。如果不需要线程安全的实现，建议使用HashMap代替Hashtable</li>
</ul>
<h3 id="1-11Lock锁"><a href="#1-11Lock锁" class="headerlink" title="1.11Lock锁"></a>1.11Lock锁</h3><p>虽然我们可以理解同步代码块和同步方法的锁对线问题，但是我们并没有直接看到在哪里加上了锁，在哪里释放了锁，为了更清晰的表达如何枷锁和释放锁，JDK5以后提供了一个新的锁对象Lock</p>
<hr>
<p>Lock实现提供比使用synchronized方法和语句可以获得更广泛的锁定操作</p>
<h5 id="Lock中提供了获得锁和释放锁的方法"><a href="#Lock中提供了获得锁和释放锁的方法" class="headerlink" title="Lock中提供了获得锁和释放锁的方法"></a>Lock中提供了获得锁和释放锁的方法</h5><ul>
<li>void lock()：获得锁</li>
<li>void unlock()：释放锁</li>
</ul>
<hr>
<p>Lock是接口不能直接实例化，这里采用它的实现类ReentrantLock来实例化</p>
<h5 id="ReentrantLock的构造方法"><a href="#ReentrantLock的构造方法" class="headerlink" title="ReentrantLock的构造方法"></a>ReentrantLock的构造方法</h5><ul>
<li>ReentrantLock()：创建一个ReentrantLock的实例</li>
</ul>
<h3 id="2-1生产者消费者模式概述"><a href="#2-1生产者消费者模式概述" class="headerlink" title="2.1生产者消费者模式概述"></a>2.1生产者消费者模式概述</h3><ul>
<li>生产者线程用于生产数据</li>
<li>消费者线程用于消费数据</li>
</ul>
<p>为了解耦生产者和消费者的关系，通常会采用共享的数据区域，就像是一个仓库</p>
<ul>
<li>生产者生产数据后直接放置在共享区域中，并不关心消费者的行为</li>
<li>消费者只需要从共享数据区中去获取数据，并不需要关心生产者的行为</li>
</ul>
<hr>
<p>为了体现生产和消费过程中的等待和唤醒，Java提供了几个方法，这几个方法在Object类中</p>
<h5 id="Object类的等待和唤醒方法："><a href="#Object类的等待和唤醒方法：" class="headerlink" title="Object类的等待和唤醒方法："></a>Object类的等待和唤醒方法：</h5><p>void wait()：导致当前线程等待，直到另一个线程调用该对象的notify()方法或notifyAll()方法</p>
<h2 id="Java网络编程"><a href="#Java网络编程" class="headerlink" title="Java网络编程"></a>Java网络编程</h2><h3 id="1-1网络编程概述"><a href="#1-1网络编程概述" class="headerlink" title="1.1网络编程概述"></a>1.1网络编程概述</h3><h4 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h4><ul>
<li>是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统</li>
</ul>
<h4 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h4><ul>
<li>在网络通信协议下，实现网络互连的不同计算机上运行的程序可以进行数据交换</li>
</ul>
<h3 id="1-2网络编程三要素"><a href="#1-2网络编程三要素" class="headerlink" title="1.2网络编程三要素"></a>1.2网络编程三要素</h3><h4 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h4><ul>
<li>想要让网络中的计算机能够互相通信，必须为每一台计算机指定一个标识号，通过这个标识号来指定要接收数据的计算机和识别发送的计算机，而IP地址就是这个标识号。也就是设备的标识</li>
</ul>
<h4 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h4><ul>
<li>网络的通信，本质上是两个应用程序的通信。每台计算机都有很多的应用程序，那么在网络通信时，如何区别这些应用程序呢？如果说IP地址可以唯一标识网络中的设备，那么多口号就可以唯一标识设备中的应用程序了，也就是应用程序的标识</li>
</ul>
<h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><ul>
<li>通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式，传输效率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。常见的协议有UDP协议和TCP协议</li>
</ul>
<h3 id="1-3IP地址"><a href="#1-3IP地址" class="headerlink" title="1.3IP地址"></a>1.3IP地址</h3><h5 id="IP地址：是网络中设备的唯一标识"><a href="#IP地址：是网络中设备的唯一标识" class="headerlink" title="IP地址：是网络中设备的唯一标识"></a>IP地址：是网络中设备的唯一标识</h5><h5 id="IP地址分为两大类"><a href="#IP地址分为两大类" class="headerlink" title="IP地址分为两大类"></a>IP地址分为两大类</h5><ul>
<li>IPv4：是给每个连接在网络上的主机分配一个32bit地址。按照TCP/IP规定，IP地址用二进制来表示，每个地址长32bit，也就是4个字节。例如一个采用二进制形式的IP地址是 “11000000 10101000 00000001 01000010 ”，这么长的地址，处理起来也费劲，为了方便使用，IP地址经常被写成十进制的形式，中间使用符号 “.” 分隔不同的字节。于是，上面的IP地址可以表示为 “192.168.1.66”。IP地址的这种表示法叫做 ”点分十进制表示法“，这显然比1和0容易记忆的多</li>
<li>IPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP分配越发紧张。为了扩大地址空间，通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组16进制数，这样就解决了网络地址资源数量不够的问题</li>
</ul>
<h5 id="常用命令："><a href="#常用命令：" class="headerlink" title="常用命令："></a>常用命令：</h5><ul>
<li>ipconfig：查看本机IP地址</li>
<li>ping IP地址：检查网络是否连通</li>
</ul>
<h5 id="特殊IP地址："><a href="#特殊IP地址：" class="headerlink" title="特殊IP地址："></a>特殊IP地址：</h5><ul>
<li>127.0.0.1：是回送地址，可以代表本机地址，一般用来测试使用</li>
</ul>
<h3 id="1-4InetAddress的使用"><a href="#1-4InetAddress的使用" class="headerlink" title="1.4InetAddress的使用"></a>1.4InetAddress的使用</h3><p>为了方便我们对IP地址的获取和操作，Java提供了一个类InetAddress供我们使用</p>
<h5 id="InetAddress：此类表示Internet协议（IP）地址"><a href="#InetAddress：此类表示Internet协议（IP）地址" class="headerlink" title="InetAddress：此类表示Internet协议（IP）地址"></a>InetAddress：此类表示Internet协议（IP）地址</h5><ul>
<li>static InetAddress getByName(String host)：确定主机名称的IP地址。主机名称可以是机器名称，也可以是IP地址</li>
<li>String getHostName()：获取此IP地址的主机名</li>
<li>String getHostAddress()：返回文本显示中的IP地址字符串</li>
</ul>
<h3 id="1-5端口"><a href="#1-5端口" class="headerlink" title="1.5端口"></a>1.5端口</h3><h5 id="端口：设备上应用程序的唯一标识"><a href="#端口：设备上应用程序的唯一标识" class="headerlink" title="端口：设备上应用程序的唯一标识"></a>端口：设备上应用程序的唯一标识</h5><h5 id="端口号："><a href="#端口号：" class="headerlink" title="端口号："></a>端口号：</h5><p>用两个字节表示的整数，它的取值范围是0<del>65535.其中，0</del>1023之间的端口号用于一些知名的网络服务和应用，普通的应用需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败</p>
<h3 id="1-6协议"><a href="#1-6协议" class="headerlink" title="1.6协议"></a>1.6协议</h3><h5 id="协议：计算机网络中，连接和通信的规则被称为网络通信协议"><a href="#协议：计算机网络中，连接和通信的规则被称为网络通信协议" class="headerlink" title="协议：计算机网络中，连接和通信的规则被称为网络通信协议"></a>协议：计算机网络中，连接和通信的规则被称为网络通信协议</h5><h5 id="UDP协议："><a href="#UDP协议：" class="headerlink" title="UDP协议："></a>UDP协议：</h5><ul>
<li>用户数据报协议（User Datagram Protocol）</li>
<li>UDP是无连接通信协议，即在数据传输时，数据的发送和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。</li>
<li>由于UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输</li>
<li>例如视频会议通常采用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。但是在使用UDP协议传送数据时，由于UDP的面向无连接型，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议</li>
</ul>
<h5 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h5><ul>
<li>传输控制协议（Transmission Control Protocol）</li>
<li>TCP协议是面向连接的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。在TCP连接中必须要明确客户端与服务器端，由客户端向服务器发出连接请求，每次连接的创建都需要经过”三次握手“</li>
<li>三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器端的三次交互，以保证连接的可靠<ul>
<li>第一次握手，客户端向服务器端发出连接请求，等待服务器确认</li>
<li>第二次握手，服务器端向客户端会送一个响应，通知客户端收到了请求</li>
<li>第三次握手，客户端再次向服务器发送确认信息，确认连接</li>
</ul>
</li>
<li>完成三次握手，建立连接后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP协议可以保证数据的安全，所以应用十分广泛。例如上传文件，下载文件和浏览网页等</li>
</ul>
<h5 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h5><p>1:服务器：准备就绪</p>
<p>2：客户端：连接请求</p>
<p>3：服务器：响应请求</p>
<h3 id="2UDP通信程序"><a href="#2UDP通信程序" class="headerlink" title="2UDP通信程序"></a>2UDP通信程序</h3><h4 id="2-1UDP通信原理"><a href="#2-1UDP通信原理" class="headerlink" title="2.1UDP通信原理"></a>2.1UDP通信原理</h4><p>UDP协议是一种不可靠的网络协议，它在通信的两端各建立一个Socket对象，但是这两个Socket只是发送，接收数据的对象</p>
<p>因此对于基于UDP协议的通信双方而言，没有所谓的客户端和服务器的概念</p>
<h4 id="2-2UDP发送数据"><a href="#2-2UDP发送数据" class="headerlink" title="2.2UDP发送数据"></a>2.2UDP发送数据</h4><h5 id="发送数据的步骤"><a href="#发送数据的步骤" class="headerlink" title="发送数据的步骤"></a>发送数据的步骤</h5><ul>
<li><p>1.创建发送端的Socket对象(DatagramSocket)</p>
<ul>
<li>DatagramSocket()</li>
</ul>
</li>
<li><p>2.创建数据，并把数据打包</p>
<ul>
<li>```java<br>DatagramPacket(byte[] buf, int length, InetAddress address, int port)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 3.调用DatagramSocket对象的方法发送数据</span><br><span class="line"></span><br><span class="line">  * void send(DatagramPacket p)</span><br><span class="line"></span><br><span class="line">* 4.关闭发送端</span><br><span class="line"></span><br><span class="line">  * void close()</span><br><span class="line"></span><br><span class="line">#### 2.3UDP接收数据</span><br><span class="line"></span><br><span class="line">##### 接收数据的步骤</span><br><span class="line"></span><br><span class="line">* 1.创建接收端的Socket对象(DatagramSocket)</span><br><span class="line">  * DatagramSocket(int port)</span><br><span class="line">* 2.创建一个数据包，用于接收数据</span><br><span class="line">  * DatagramPacket(byte[] buf, int length)</span><br><span class="line">* 3.调用DatagramSocket对象的方法接收数据</span><br><span class="line">  * void receive(DatagramPacket p)</span><br><span class="line">* 4.解析数据包，并将数据在控制台显示</span><br><span class="line">  * byte[] getData()</span><br><span class="line">  * int getLength()</span><br><span class="line">* 5.关闭接收端</span><br><span class="line">  * void close()</span><br><span class="line"></span><br><span class="line">#### 2.4UDP通信程序联系</span><br><span class="line"></span><br><span class="line">##### 按照下面的要求实现程序</span><br><span class="line"></span><br><span class="line">* UDP发送数据：数据来自于键盘录入，直到输入的数是886，发送数据结束</span><br><span class="line">* UDP接收数据：因为接收端不知道发送端什么时候停止发送，故采用死循环接收</span><br><span class="line"></span><br><span class="line">### 3.TCP通信程序</span><br><span class="line"></span><br><span class="line">#### 3.1TCP通信原理</span><br><span class="line"></span><br><span class="line">TCP通信协议是一种可靠的网络协议，它在通信的两端各建立一个Socket对象，从而在通信的两端形成网络虚拟链路，一旦建立了虚拟的网络链路，两端的程序就可以通过虚拟链路进行通信</span><br><span class="line"></span><br><span class="line">-------</span><br><span class="line"></span><br><span class="line">Java对基于TCP协议的网络提供了良好的封装，使用Socket对象来代替两端的通信端口，并通过Socket产生IO流来进行网络通信</span><br><span class="line"></span><br><span class="line">Java为客户端提供了Socket类，为服务器端提供了ServerSocket类</span><br><span class="line"></span><br><span class="line">#### 3.2TCP发送数据</span><br><span class="line"></span><br><span class="line">##### 发送数据的步骤</span><br><span class="line"></span><br><span class="line">* 创建客户端的Socket对象(Socket)</span><br><span class="line">  * Socket(String host, int port)</span><br><span class="line">* 获取输出流，写数据</span><br><span class="line">  * OutputStream getOutputStream()</span><br><span class="line">* 释放资源</span><br><span class="line">  * void close()</span><br><span class="line"></span><br><span class="line">#### 3.3TCP接收数据</span><br><span class="line"></span><br><span class="line">##### 接收数据的步骤</span><br><span class="line"></span><br><span class="line">* 1.创建服务器端的Socket对象（ServerSocket）</span><br><span class="line"></span><br><span class="line">  * ServerSocket(int port)</span><br><span class="line"></span><br><span class="line">* 2.监听客户端连接，返回一个Socket对象</span><br><span class="line"></span><br><span class="line">  * Socket accept()</span><br><span class="line"></span><br><span class="line">* 3.获取输入流，读数据，并把数据显示在控制台</span><br><span class="line"></span><br><span class="line">  * InputStream getInputStream()</span><br><span class="line"></span><br><span class="line">* 4.释放资源</span><br><span class="line"></span><br><span class="line">  * void close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 小Tips：程序一直等待用shutdownOutput()方法</span><br><span class="line"></span><br><span class="line">## Lambda表达式</span><br><span class="line"></span><br><span class="line">### 1.1函数式编程思想概述</span><br><span class="line"></span><br><span class="line">在数学中，函数就是有输入量、输出量的一套计算方案，也就是“拿数据做操作”</span><br><span class="line"></span><br><span class="line">面向对象思想强调“必须通过对象的形式来做事情”</span><br><span class="line"></span><br><span class="line">函数式思想则尽量忽略面向对象的复杂语法：“强调做什么，而不是以什么形式去做”</span><br><span class="line"></span><br><span class="line">##### Lambda表达式就是函数式思想的体现</span><br><span class="line"></span><br><span class="line">### 1.2体验Lambda表达式</span><br><span class="line"></span><br><span class="line">##### 需求：启动一个线程，在控制台输出一句话：多线程程序启动了</span><br><span class="line"></span><br><span class="line">* 方式1：</span><br><span class="line"></span><br><span class="line">  * 定义一个类MyRunnable实现Runnable接口，重写run()方法</span><br><span class="line">  * 创建MyRunnable类的对象</span><br><span class="line">  * 创建Thread类的对象，把MyRunnable的对象作为构造参数传递</span><br><span class="line">  * 启动线程</span><br><span class="line"></span><br><span class="line">* 方式2：</span><br><span class="line"></span><br><span class="line">  * 匿名内部类</span><br><span class="line"></span><br><span class="line">* 方式3：</span><br><span class="line"></span><br><span class="line">  * Lambda表达式：</span><br><span class="line"></span><br><span class="line">  * &#96;&#96;&#96;java</span><br><span class="line">    new Thread( () -&gt; &#123;</span><br><span class="line">        System.out.println(&quot;多线程程序启动了&quot;);</span><br><span class="line">    &#125; ).start();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="1-3Lambda表达式的标准格式"><a href="#1-3Lambda表达式的标准格式" class="headerlink" title="1.3Lambda表达式的标准格式"></a>1.3Lambda表达式的标准格式</h3><h5 id="匿名内部类中重写run-方法的代码分析"><a href="#匿名内部类中重写run-方法的代码分析" class="headerlink" title="匿名内部类中重写run()方法的代码分析"></a>匿名内部类中重写run()方法的代码分析</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;多线程程序启动了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<ul>
<li>方法形式参数为空，说明调用方法时不用传参</li>
<li>方法返回值类型为void，说明方法执行没有结果返回</li>
<li>方法体中的内容，是我们具体要做的事情</li>
</ul>
<h5 id="Lambda表达式的代码分析"><a href="#Lambda表达式的代码分析" class="headerlink" title="Lambda表达式的代码分析"></a>Lambda表达式的代码分析</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread( () -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;多线程程序启动了&quot;</span>);</span><br><span class="line">&#125; ).start();</span><br></pre></td></tr></table></figure>

<ul>
<li>()：里面没有内容，可以看成是方法形式参数为空</li>
<li>-&gt;：用箭头指向后面要做的事情</li>
<li>{}：包含一段代码，我们称之为代码块，可以看成是方法体中的内容</li>
<li>组成Lambda表达式的三要素：形式参数、箭头、代码块</li>
</ul>
<h5 id="Lambda表达式的格式"><a href="#Lambda表达式的格式" class="headerlink" title="Lambda表达式的格式"></a>Lambda表达式的格式</h5><ul>
<li>格式：(形式参数) -&gt; {代码块}</li>
<li>形式参数：如果有多个参数，参数之间用逗号隔开；如果没有参数，留空即可</li>
<li>-&gt;：由英文中画线和大于符号构成，固定写法。代表指向动作</li>
<li>代码块：是我们具体要做的事情，也就是以前我们写的方法体内容</li>
</ul>
<h3 id="1-4Lambda表达式的练习"><a href="#1-4Lambda表达式的练习" class="headerlink" title="1.4Lambda表达式的练习"></a>1.4Lambda表达式的练习</h3><h5 id="Lambda表达式的使用前提"><a href="#Lambda表达式的使用前提" class="headerlink" title="Lambda表达式的使用前提"></a>Lambda表达式的使用前提</h5><ul>
<li>有一个接口</li>
<li>接口中有且仅有一个抽象方法</li>
</ul>
<h5 id="练习1"><a href="#练习1" class="headerlink" title="练习1"></a>练习1</h5><ul>
<li><p>定义一个接口(Eatable)，里面定义一个抽象方法：void eat();</p>
</li>
<li><p>定义一个测试类(EatableDemo)，在测试类中提供两个方法</p>
<ul>
<li><p>一个方法是：useEatable(Eatable e)</p>
</li>
<li><p>一个方法是主方法：在主方法中调用useEatable方法</p>
</li>
<li><p>```java<br>public static void main(String[] args) {</p>
<pre><code>Eatable e = new EatableImpl();
useEatable(e);

//        匿名内部类
useEatable(new Eatable() &#123;
    @Override
    public void eat() &#123;
        System.out.println(&quot;一天两天是哪天&quot;);
    &#125;
&#125;);

//        Lambda表达式
useEatable( () -&gt; &#123;
    System.out.println(&quot;一天两天是哪天&quot;);
&#125; );
</code></pre>
<p>}<br>private static void useEatable(Eatable e) {</p>
<pre><code>e.eat();
</code></pre>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### 两个参数且有返回值的情况</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    &#x2F;&#x2F;在主方法中调用useAddable方法</span><br><span class="line">    useAddable((int x,int y) -&gt; &#123;</span><br><span class="line">        return x + y;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">private static void useAddable(Addable a)&#123;</span><br><span class="line">    int sum &#x3D; a.add(10,20);</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="1-5Lambda表达式的省略模式"><a href="#1-5Lambda表达式的省略模式" class="headerlink" title="1.5Lambda表达式的省略模式"></a>1.5Lambda表达式的省略模式</h3><h5 id="省略规则："><a href="#省略规则：" class="headerlink" title="省略规则："></a>省略规则：</h5><ul>
<li>参数类型可以省略。但是有多个参数的情况下，不能只省略一个</li>
<li>如果参数有且仅有一个，那么小括号可以省略</li>
<li>如果代码块的语句只有一条，可以省略大括号和分号，甚至是return</li>
</ul>
<h3 id="1-6Lambda表达式的注意事项"><a href="#1-6Lambda表达式的注意事项" class="headerlink" title="1.6Lambda表达式的注意事项"></a>1.6Lambda表达式的注意事项</h3><h5 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h5><ul>
<li>使用Lambda必须要有接口，并且要求接口中有且仅有一个抽象方法</li>
<li>必须有上下文环境，才能推导出Lambda对应的接口<ul>
<li>根据局部变量的赋值得知Lambda对应的接口：Runnable r = () -&gt; Sytem.out.println(“Lambda表达式”);</li>
<li>根据调用方法的参数得知Lambda对应的接口：new Thread(() -&gt; System.out.println(“Lambda表达式”)).start();</li>
</ul>
</li>
</ul>
<h3 id="1-7Lambda表达式和匿名内部类的区别"><a href="#1-7Lambda表达式和匿名内部类的区别" class="headerlink" title="1.7Lambda表达式和匿名内部类的区别"></a>1.7Lambda表达式和匿名内部类的区别</h3><h5 id="所需类型不同"><a href="#所需类型不同" class="headerlink" title="所需类型不同"></a>所需类型不同</h5><ul>
<li>匿名内部类：可以是接口，也可以是抽象类，还可以是具体类</li>
<li>Lambda表达式：只能是接口</li>
</ul>
<h5 id="使用限制不同"><a href="#使用限制不同" class="headerlink" title="使用限制不同"></a>使用限制不同</h5><ul>
<li>如果接口中有且仅有一个抽象方法，可以使用Lambda表达式，也可以使用匿名内部类</li>
<li>如果接口中多余一个抽象方法，只能使用匿名内部类，而不能使用Lambda表达式</li>
</ul>
<h2 id="接口组成更新"><a href="#接口组成更新" class="headerlink" title="接口组成更新"></a>接口组成更新</h2><h3 id="1-1接口组成更新概述"><a href="#1-1接口组成更新概述" class="headerlink" title="1.1接口组成更新概述"></a>1.1接口组成更新概述</h3><h5 id="接口的组成"><a href="#接口的组成" class="headerlink" title="接口的组成"></a>接口的组成</h5><ul>
<li>常量<ul>
<li>public static final</li>
</ul>
</li>
<li>抽象方法<ul>
<li>public abstract</li>
</ul>
</li>
<li>默认方法（Java 8）</li>
<li>静态方法（Java 8）</li>
<li>私有方法（Java 9）</li>
</ul>
<h3 id="1-2接口中的默认方法"><a href="#1-2接口中的默认方法" class="headerlink" title="1.2接口中的默认方法"></a>1.2接口中的默认方法</h3><h5 id="接口中默认方法的定义格式："><a href="#接口中默认方法的定义格式：" class="headerlink" title="接口中默认方法的定义格式："></a>接口中默认方法的定义格式：</h5><ul>
<li>格式：public default 返回值类型 方法名(参数列表) {}</li>
<li>范例：public default void show() {}</li>
</ul>
<h5 id="接口中默认方法的注意事项："><a href="#接口中默认方法的注意事项：" class="headerlink" title="接口中默认方法的注意事项："></a>接口中默认方法的注意事项：</h5><ul>
<li>默认方法不是抽象方法，所以不强制被重写。但是可以被重写，重写的时候去掉default关键字</li>
<li>public可以省略，default不能省略</li>
</ul>
<h3 id="1-3接口中的静态方法"><a href="#1-3接口中的静态方法" class="headerlink" title="1.3接口中的静态方法"></a>1.3接口中的静态方法</h3><h5 id="接口中静态方法的定义格式："><a href="#接口中静态方法的定义格式：" class="headerlink" title="接口中静态方法的定义格式："></a>接口中静态方法的定义格式：</h5><ul>
<li>格式：public static 返回值类型 方法名(参数列表) {}</li>
<li>范例：public static void show() {}</li>
</ul>
<h5 id="接口中静态方法的注意事项："><a href="#接口中静态方法的注意事项：" class="headerlink" title="接口中静态方法的注意事项："></a>接口中静态方法的注意事项：</h5><ul>
<li>静态方法只能通过接口名调用，不能通过实现类名或对象名调用</li>
<li>public可以省略，static不能省略</li>
</ul>
<h3 id="1-4接口中私有方法"><a href="#1-4接口中私有方法" class="headerlink" title="1.4接口中私有方法"></a>1.4接口中私有方法</h3><h5 id="接口中私有方法的定义格式："><a href="#接口中私有方法的定义格式：" class="headerlink" title="接口中私有方法的定义格式："></a>接口中私有方法的定义格式：</h5><ul>
<li>格式1：private 返回值类型 方法名(参数列表) {}</li>
<li>范例1：private void show() {}</li>
<li>格式2：private static 返回值类型 方法名(参数列表) {}</li>
<li>范例2：private static void method() {}</li>
</ul>
<h5 id="接口中私有方法的注意事项："><a href="#接口中私有方法的注意事项：" class="headerlink" title="接口中私有方法的注意事项："></a>接口中私有方法的注意事项：</h5><ul>
<li>默认方法可以调用私有的静态方法和非静态方法</li>
<li>静态方法只能调用私有的静态方法</li>
</ul>
<h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><h3 id="1-1体验方法引用"><a href="#1-1体验方法引用" class="headerlink" title="1.1体验方法引用"></a>1.1体验方法引用</h3><p>在使用Lambda表达式时，我们实际传进去的代码就是一种解决方案：拿参数做操作</p>
<p>那么考虑一种情况：如果我们在Lambda中所指定的操作方案，已经有地方存在相同方案，那是否还有必要重写重复逻辑呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//        方法引用符：::</span></span><br><span class="line">        usePrintable(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        可推导的就是可省略的</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2方法引用符"><a href="#1-2方法引用符" class="headerlink" title="1.2方法引用符"></a>1.2方法引用符</h3><h5 id="方法引用符"><a href="#方法引用符" class="headerlink" title="方法引用符"></a>方法引用符</h5><ul>
<li>:: 该符号为引用运算符，而它所在的表达式被称为方法引用</li>
</ul>
<h5 id="回顾一下我们在体验方法引用中的代码"><a href="#回顾一下我们在体验方法引用中的代码" class="headerlink" title="回顾一下我们在体验方法引用中的代码"></a>回顾一下我们在体验方法引用中的代码</h5><ul>
<li>Lambda表达式：usePrintable(s -&gt; System.out.println(s));<ul>
<li>分析：拿到参数s后通过Lambda表达式，传递给System.out.printlb方法去处理</li>
</ul>
</li>
<li>方法引用：usePrintable(System.out::println);<ul>
<li>分析：直接使用System.out中的println方法来取代Lambda，代码更加简洁</li>
</ul>
</li>
</ul>
<h5 id="推导与省略"><a href="#推导与省略" class="headerlink" title="推导与省略"></a>推导与省略</h5><ul>
<li>如果使用Lambda，那么根据“可推导就是可省略”的原则，无需指定参数类型，也无需指定的重载形式，它们都将被自动推导</li>
<li>如果使用方法引用，也是同样可以根据上下文进行推导</li>
<li>方法引用时Lambda的孪生兄弟</li>
</ul>
<h3 id="1-3Lambda表达式支持的方法引用"><a href="#1-3Lambda表达式支持的方法引用" class="headerlink" title="1.3Lambda表达式支持的方法引用"></a>1.3Lambda表达式支持的方法引用</h3><h5 id="常见的引用方式："><a href="#常见的引用方式：" class="headerlink" title="常见的引用方式："></a>常见的引用方式：</h5><ul>
<li>引用类方法</li>
<li>引用对象的实例方法</li>
<li>引用类的实例方法</li>
<li>引用构造器</li>
</ul>
<h3 id="1-4引用类方法"><a href="#1-4引用类方法" class="headerlink" title="1.4引用类方法"></a>1.4引用类方法</h3><h5 id="引用方法，其实就是引用类的静态方法"><a href="#引用方法，其实就是引用类的静态方法" class="headerlink" title="引用方法，其实就是引用类的静态方法"></a>引用方法，其实就是引用类的静态方法</h5><ul>
<li>格式：类名::静态方法</li>
<li>范例：Integer::parseInt<ul>
<li>Integer类的方法：public static int parseInt(String s)将此String类转换为int类型数据</li>
</ul>
</li>
<li>Lambda表达式被类方法替代的时候，它的形式参数全部传递给静态方法作为参数</li>
</ul>
<h3 id="1-5引用对象的实例方法"><a href="#1-5引用对象的实例方法" class="headerlink" title="1.5引用对象的实例方法"></a>1.5引用对象的实例方法</h3><h5 id="引用对象的实例方法，其实就是引用类中的成员方法"><a href="#引用对象的实例方法，其实就是引用类中的成员方法" class="headerlink" title="引用对象的实例方法，其实就是引用类中的成员方法"></a>引用对象的实例方法，其实就是引用类中的成员方法</h5><ul>
<li>对象::成员方法</li>
<li>范例：”HelloWorld”::toUpperCase<ul>
<li>String类中的方法：public String toUpperCase() 将此String所有字符转换为大写</li>
</ul>
</li>
<li>Lambda表达式被对象的实例方法替代的时候，它的形式参数全部传递给该方法作为参数</li>
</ul>
<h3 id="1-6引用类的实例方法"><a href="#1-6引用类的实例方法" class="headerlink" title="1.6引用类的实例方法"></a>1.6引用类的实例方法</h3><h5 id="引用类的实例方法，其实就是引用类的成员方法"><a href="#引用类的实例方法，其实就是引用类的成员方法" class="headerlink" title="引用类的实例方法，其实就是引用类的成员方法"></a>引用类的实例方法，其实就是引用类的成员方法</h5><ul>
<li>格式：类名::成员方法</li>
<li>范例：String::subString<ul>
<li>String类中的方法：public String subString(int beginIndex, int endIndex)从beginIndex开始到endIndex结束，截取字符串。返回一个字串，子串的长度为endIndex-beginIndex</li>
</ul>
</li>
<li>Lambda表达式被类的实例方法替代的时候，第一个参数作为调用者，后面的参数全部传递给该方法作为参数</li>
</ul>
<h3 id="1-7引用构造器"><a href="#1-7引用构造器" class="headerlink" title="1.7引用构造器"></a>1.7引用构造器</h3><h5 id="引用构造器，其实就是引用构造方法"><a href="#引用构造器，其实就是引用构造方法" class="headerlink" title="引用构造器，其实就是引用构造方法"></a>引用构造器，其实就是引用构造方法</h5><ul>
<li>格式：类名::new</li>
<li>范例：Student::new</li>
<li>Lambda表达式被构造器替代时，它的形式参数全部传递给构造器作为参数</li>
</ul>
<h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><h3 id="1-1函数式接口概述"><a href="#1-1函数式接口概述" class="headerlink" title="1.1函数式接口概述"></a>1.1函数式接口概述</h3><p>函数式接口：有且仅有一个抽象方法的接口</p>
<p>Java中的函数式编程体现就是Lambda表达式，所以函数式接口就是可以用于Lambda使用的接口</p>
<p>只有确保接口中有且仅有一个抽象方法，Java中的Lambda才能顺利地进行推导</p>
<h5 id="如何检测一个接口是不是函数式接口呢？"><a href="#如何检测一个接口是不是函数式接口呢？" class="headerlink" title="如何检测一个接口是不是函数式接口呢？"></a>如何检测一个接口是不是函数式接口呢？</h5><ul>
<li>@FunctionalInterface</li>
<li>放在接口定义的上方：如果接口是函数式接口，编译通过；如果不是，编译失败</li>
</ul>
<h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><ul>
<li>我们自己定义函数式接口的时候，@FunctionalInterface是可选的，就算我不写这个注解，只要保证满足函数式接口定义的条件，也照样是函数式接口。但是，建议加上该注解</li>
</ul>
<h3 id="1-2函数式接口作为方法的参数"><a href="#1-2函数式接口作为方法的参数" class="headerlink" title="1.2函数式接口作为方法的参数"></a>1.2函数式接口作为方法的参数</h3><h5 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h5><ul>
<li><p>定义一个类(RunnableDemo)，在类中提供两个方法</p>
<ul>
<li><p>一个方法是：startThread(Runnable r) 方法参数Runnable是一个函数式接口</p>
</li>
<li><p>一个是主方法，在主方法调用startThread方法</p>
</li>
<li><p>```java<br>public class RunnableDemo {</p>
<pre><code>public static void main(String[] args) &#123;
    //在主方法调用startThread方法
    
    //匿名内部类的方式
    startThread(new Runnable() &#123;
        @Override
        public void run() &#123;
            System.out.println(Thread.currentThread().getName() + &quot;线程启动了&quot;);
        &#125;
    &#125;);
    
    //Lambda表达式
    startThread(() -&gt; System.out.println(Thread.currentThread().getName() + &quot;线程启动了&quot;));
&#125;
private static void startThread(Runnable r) &#123;
     //Thread t = new Thread(r);
    //t.start();
    new Thread(r).start();
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">### 1.3函数式接口作为方法的返回值</span><br><span class="line"></span><br><span class="line">##### 需求</span><br><span class="line"></span><br><span class="line">* 定义一个类(ComparatorDemo)，在类中提供两个方法</span><br><span class="line">  * 一个方法是：Comparator&lt;String&gt; getComparator()方法返回值Comparator是一个函数式接口</span><br><span class="line">  * 一个方法是主方法，在主方法中调用getComparator方法</span><br><span class="line"></span><br><span class="line">##### 实现</span><br><span class="line"></span><br><span class="line">* &#96;&#96;&#96;java</span><br><span class="line">  public class ComparatorDemo &#123;</span><br><span class="line">      public static void main(String[] args) &#123;</span><br><span class="line">          &#x2F;&#x2F;构造使用场景</span><br><span class="line">          &#x2F;&#x2F;定义集合，存储字符串元素</span><br><span class="line">          ArrayList&lt;String&gt; array &#x3D; new ArrayList&lt;String&gt; ();</span><br><span class="line">          </span><br><span class="line">          array.add(&quot;cccc&quot;);</span><br><span class="line">          array.add(&quot;aa&quot;);</span><br><span class="line">          array.add(&quot;b&quot;);</span><br><span class="line">          array.add(&quot;ddd&quot;);</span><br><span class="line">          </span><br><span class="line">          System.out.println(&quot;排序前：&quot; + array );</span><br><span class="line">          </span><br><span class="line">          &#x2F;&#x2F;Collections.sort(array);</span><br><span class="line">          Collections.sort(array,getComparator());</span><br><span class="line">          </span><br><span class="line">          System.out.println(&quot;排序后：&quot; + array);</span><br><span class="line">      &#125;</span><br><span class="line">      public static Comparator&lt;String&gt; getComparator() &#123;</span><br><span class="line">          &#x2F;&#x2F;匿名内部类实现</span><br><span class="line">          Comparator&lt;String&gt; comp &#x3D; new Comparator&lt;String&gt;() &#123;</span><br><span class="line">              @Override</span><br><span class="line">              public int compare(String s1, String s2) &#123;</span><br><span class="line">                  return s1.length() - s2.length();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;;</span><br><span class="line">          return comp;</span><br><span class="line">          </span><br><span class="line">        	&#x2F;&#x2F;Lambda表达式实现</span><br><span class="line">          return (String s1,String s2) -&gt; &#123;</span><br><span class="line">              return s1.length() -s2.length();</span><br><span class="line">          &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h5 id="如果方法的返回值是一个函数式接口，我们可以使用Lambda表达式作为结果返回"><a href="#如果方法的返回值是一个函数式接口，我们可以使用Lambda表达式作为结果返回" class="headerlink" title="如果方法的返回值是一个函数式接口，我们可以使用Lambda表达式作为结果返回"></a>如果方法的返回值是一个函数式接口，我们可以使用Lambda表达式作为结果返回</h5><ul>
<li><p>```java<br>private Comparator<String> getComparator() { </p>
<pre><code>return (s1,s2) -&gt; s1.length() = s2.length();
</code></pre>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 1.4常用的函数式接口</span><br><span class="line"></span><br><span class="line">* Supplier接口</span><br><span class="line">* Consumer接口</span><br><span class="line">* Predicate接口</span><br><span class="line">* Function接口</span><br><span class="line"></span><br><span class="line">### 1.5Supplier接口</span><br><span class="line"></span><br><span class="line">##### Supplier&lt;T&gt;：包含一个无参的方法</span><br><span class="line"></span><br><span class="line">* T get()：获得结果</span><br><span class="line">* 该方法不需要参数，它会按照某种实现逻辑(由Lambda表达式实现)返回一个数据</span><br><span class="line">* Supplier&lt;T&gt;接口也被称为生产型接口，如果我们指定了接口的泛型是什么类型，那么接口中的get方法就会生产什么类型的数据供我们使用</span><br><span class="line"></span><br><span class="line">### 1.6Comsumer接口</span><br><span class="line"></span><br><span class="line">##### Consumer&lt;T&gt;：包含两个方法</span><br><span class="line"></span><br><span class="line">* void accpet(T t)：对给定的参数执行此操作</span><br><span class="line">* default Consumer&lt;T&gt; andThen(Consumer after)：返回一个组合的Consumer，依次执行此操作，然后执行after操作</span><br><span class="line">* Consumer&lt;T&gt;接口也被称为消费型接口，它消费的数据的数据类型由泛型指定</span><br><span class="line"></span><br><span class="line">##### 练习</span><br><span class="line"></span><br><span class="line">* String[] strArray &#x3D; &#123;&quot;林青霞,30&quot;,&quot;张曼玉,35&quot;,&quot;王祖贤,33&quot;&#125;;</span><br><span class="line">* 要求：</span><br><span class="line">  * 把打印姓名的动作作为第一个Consumer接口的Lambda实例</span><br><span class="line">  * 把打印年龄的动作作为第二个Consumer接口的Lambda实例</span><br><span class="line">  * 将两个Consumer接口按照顺序组合到一起使用</span><br><span class="line"></span><br><span class="line">### 1.7Predicate接口</span><br><span class="line"></span><br><span class="line">##### Predicate接口：常用的四个方法</span><br><span class="line"></span><br><span class="line">* boolean test(T t)：对给定的参数进行判断（判断逻辑由Lambda表达式实现），返回一个布尔值</span><br><span class="line">* default Predicate&lt;T&gt; negate()：返回一个逻辑的否定，对应逻辑非</span><br><span class="line">* default Predicate&lt;T&gt; and(Predicate other)：返回一个组合判断，对应短路与</span><br><span class="line">* default Predicate&lt;T&gt; or(Predicate other)：返回一个组合判断，对应短路与</span><br><span class="line">* Predicate&lt;T&gt;接口通常用于判断参数是否满足指定条件</span><br><span class="line"></span><br><span class="line">### 1.8Function接口</span><br><span class="line"></span><br><span class="line">##### Function&lt;T,R&gt;：常用的两个方法</span><br><span class="line"></span><br><span class="line">* R apply(T,t)：将此函数应用于给定的参数</span><br><span class="line">* default&lt;V&gt; Function andThen(Function after)：返回一个组合函数，首先将该函数应用于输入，然后将after函数应用于结果</span><br><span class="line">* Function&lt;T,R&gt;接口通常用于对参数进行处理，转换（处理逻辑由Lambda表达式实现），然后返回一个新的值</span><br><span class="line"></span><br><span class="line">## Stream流</span><br><span class="line"></span><br><span class="line">### 1.1体验Stream流</span><br><span class="line"></span><br><span class="line">##### 使用Stream流完成过滤操作</span><br><span class="line"></span><br><span class="line">* list.stream().filter(s -&gt; s.startsWith(&quot;张&quot;)).filter(s -&gt;s.length() &#x3D;&#x3D; 3).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">* 直接阅读代码的字面意思即可完美展示无关逻辑方式的语义：生成流、过滤姓、过滤名字长度、遍历</span><br><span class="line"></span><br><span class="line">### 1.2Stream流的生成方式</span><br><span class="line"></span><br><span class="line">##### Stream流的使用</span><br><span class="line"></span><br><span class="line">* 生成流</span><br><span class="line">  * 通过数据源（集合、数组等）生成流</span><br><span class="line">  * list.stream()</span><br><span class="line">* 中间操作</span><br><span class="line">  * 一个流后面可以跟随零个或多个中间操作，其重要目的是打开流，做出某种程度的数据过滤&#x2F;映射，然后返回一个新的流，交给下一个操作使用</span><br><span class="line">  * filter()</span><br><span class="line">* 终结操作</span><br><span class="line">  * 一个流只能有一个终结操作，当这个操作被执行后，流就被使用“光”了，无法再被操作，所以这必定是流的最后一个操作</span><br><span class="line">  * forEach()</span><br><span class="line"></span><br><span class="line">##### Stream流的常见生成方式</span><br><span class="line"></span><br><span class="line">* Collection体系的集合可以使用默认方法stream()生成流</span><br><span class="line">  * default Stream&lt;E&gt; stream()</span><br><span class="line">* Map体系的集合间接的生成流</span><br><span class="line">* 数组可以通过Stream接口的静态方法of(T... values)生成流</span><br><span class="line"></span><br><span class="line">### 1.3Stream流的常见中间操作方法</span><br><span class="line"></span><br><span class="line">* Stream&lt;T&gt; filter(Predicate p)：用于对流中的数据进行过滤</span><br><span class="line">  * Predicate接口中的方法：boolean test(T t)：对给定的参数进行判断，返回一个布尔值</span><br><span class="line">* Stream&lt;T&gt; limit(long maxSize)：返回此流中的元素组成的流，截取前指定参数个数的数据</span><br><span class="line">* Stream&lt;T&gt; skip(long n)：跳过指定参数个数的数据，返回由该流的剩余元素组成的流</span><br><span class="line">* static&lt;T&gt; Stream&lt;T&gt; concat(Stream a,Stream b)：合并a和b两个流为一个流</span><br><span class="line">* Stream&lt;T&gt; distinct()：返回由该流的不同元素（根据Object.equals(Object)）组成的流</span><br><span class="line">* Stream&lt;T&gt; sorted()：返回由此流的元素组成的流，根据自然顺序排序</span><br><span class="line">* Stream&lt;T&gt; sorted(Comparator comparator)：返回由该流的元素组成的流，根据提供的Comparator进行排序</span><br><span class="line">* &lt;R&gt; Stream&lt;R&gt; map(Function mapper)：返回由给定函数应用于此流的元素的结果组成的流</span><br><span class="line">  * Function接口中的方法：R apply(T t)</span><br><span class="line">* IntStream mapToInt(ToIntFunction mapper)：返回一个IntStream其中包括将给定函数应用于此流的元素的结果</span><br><span class="line">  * IntStream：表示原始int流</span><br><span class="line">  * ToIntFunction接口中的方法：int applyAsInt(T value)</span><br><span class="line"></span><br><span class="line">### 1.4Stream流的常见终结操作方法</span><br><span class="line"></span><br><span class="line">##### Stream流的常见终结操作方法</span><br><span class="line"></span><br><span class="line">* void forEach(Consumer action)：对此流的每个元素执行操作</span><br><span class="line">  * Consumer接口中的方法：void accept(T t)：对给定的参数执行此操作</span><br><span class="line">* long count()：返回此流中的元素数</span><br><span class="line"></span><br><span class="line">### 1.5Stream流的收集操作</span><br><span class="line"></span><br><span class="line">##### Stream流的收集方法</span><br><span class="line"></span><br><span class="line">* R collect(Collector collector)</span><br><span class="line">* 但这个收集方法的参数是一个Collector接口</span><br><span class="line"></span><br><span class="line">##### 工具类Collectors提供了具体的收集方式</span><br><span class="line"></span><br><span class="line">* public static &lt;T&gt; Collector toList()：把元素收集到List集合中</span><br><span class="line">* public static &lt;T&gt; Collector toSet()：把元素收集到Set集合中</span><br><span class="line">* public static Collector toMap(Function keyMapper, Function valueMapper)：把元素收集到Map集合中</span><br><span class="line"></span><br><span class="line">## 类加载器</span><br><span class="line"></span><br><span class="line">### 1.1类加载</span><br><span class="line"></span><br><span class="line">当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过类的加载，类的连接，类的初始化这三个步骤来对类进行初始化。如果不出现意外情况，JVM将会连续完成这三个步骤，所以有时也把这三个步骤统称为类加载或类初始化</span><br><span class="line"></span><br><span class="line">-----------</span><br><span class="line"></span><br><span class="line">##### 类的加载</span><br><span class="line"></span><br><span class="line">* 就是指将class文件读入内存，并为之创建一个java.lang.Class对象</span><br><span class="line">* 任何类被使用时，系统都会为之建立一个java.lang.Class对象</span><br><span class="line"></span><br><span class="line">##### 类的连接</span><br><span class="line"></span><br><span class="line">* 验证阶段：用于检验被加载的类是否有正确的内部结构，并和其他类协调一致</span><br><span class="line">* 准备阶段：负责为类的类变量分配内存，并设置默认初始化值</span><br><span class="line">* 解析阶段：将类的二进制数据中的符号引用替换为直接引用</span><br><span class="line"></span><br><span class="line">##### 类的初始化</span><br><span class="line"></span><br><span class="line">* 在该阶段，主要就是对类变量进行初始化</span><br><span class="line"></span><br><span class="line">##### 类的初始化步骤</span><br><span class="line"></span><br><span class="line">* 假如类还未被加载和连接，则程序先加载并连接该类</span><br><span class="line">* 假如该类的直接父类还未被初始化，则先初始化其父类</span><br><span class="line">* 加入类中有初始化语句，则系统依次执行这些初始化语句</span><br><span class="line">* 注意：在执行第二个步骤时，系统对直接父类的初始化步骤也遵循初始化步骤1-3</span><br><span class="line"></span><br><span class="line">##### 类的初始化时机</span><br><span class="line"></span><br><span class="line">* 创建类的实例</span><br><span class="line">* 调用类的类方法</span><br><span class="line">* 访问类或者接口的类变量，或者为该类变量赋值</span><br><span class="line">* 使用反射方式来强制创建某个类或接口对应的java.lang.Class对象</span><br><span class="line">* 初始化某个类的子类</span><br><span class="line">* 直接使用java.exe命令来运行某个主类</span><br><span class="line"></span><br><span class="line">### 1.2类加载器</span><br><span class="line"></span><br><span class="line">##### 类加载器的作用</span><br><span class="line"></span><br><span class="line">* 负责将.class文件加载到内存中，并为之生成对应的java.lang.Class对象</span><br><span class="line">* 虽然我们不用过分关心类加载机制，但是了解这个机制我们就能更好地理解程序的运行</span><br><span class="line"></span><br><span class="line">##### JVM的类加载机制</span><br><span class="line"></span><br><span class="line">* 全盘负责：就是当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另一个类加载器来载入</span><br><span class="line">* 父类委托：就是当一个类加载器负责加载某个Class时，先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</span><br><span class="line">* 缓存机制：保证所有加载过的Class都会被缓存，当程序需要使用某个Class对象时，类加载器先从缓存区中搜索该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存储到缓存区</span><br><span class="line"></span><br><span class="line">##### ClassLoader：是负责加载类的对象</span><br><span class="line"></span><br><span class="line">##### Java运行时具有以下的内置类加载器</span><br><span class="line"></span><br><span class="line">* Bootstrap class loader：它是虚拟机的内置类加载器，通常表示为null，并且没有父null</span><br><span class="line">* Platform class loader：平台类加载器可以看到所有平台类，平台类包括由平台类加载器或其祖先定义的Java SE平台API，其实现类和JDK特定的运行时类</span><br><span class="line">* System class loader：它被称为应用程序类加载器，与平台类加载器不同。系统类加载器通常用于定义应用程序类路径，模块路径和JDK特定工具上的类</span><br><span class="line">* 类加载器的继承关系：System的父加载器为Platform，而Platform的父加载器为Bootstrap</span><br><span class="line"></span><br><span class="line">##### ClassLoader中的两个方法</span><br><span class="line"></span><br><span class="line">* static ClassLoader getSystemClassLoader()：返回用于委派的系统类加载器</span><br><span class="line">* ClassLoader getParent()：返回父类加载器进行委派</span><br><span class="line"></span><br><span class="line">## 反射</span><br><span class="line"></span><br><span class="line">### 1.1反射概述</span><br><span class="line"></span><br><span class="line">Java反射机制：是指在运行时去获取一个类的变量和方法信息。然后通过获取到的信息来创建对象，调用方法的一种机制。由于这种动态性，可以极大的增强程序的灵活性，程序不用在编译器就完成确定，在运行期仍然可以扩展</span><br><span class="line"></span><br><span class="line">### 1.2获取Class类的对象</span><br><span class="line"></span><br><span class="line">我们要想通过反射区使用一个类，首先我们要获取到该类的字节码文件对象，也就是类型为Class类型的对象，这里我们提供三种方式获取Class类型的对象</span><br><span class="line"></span><br><span class="line">* 使用类的class属性来获取该类对应的Class对象。举例：Student.class将会返回Student类对应的Class对象</span><br><span class="line">* 调用对象的getClass()方法，返回该对象所属类对应的Class对象</span><br><span class="line">  * 该方法时Object类中的方法，所有的Java对象都可以调用该方法</span><br><span class="line">* 使用Class类中的静态方法forName(String className)，该方法需要传入字符串参数，该字符串参数的值是某个类的全路径，也就是完整包名的路径</span><br><span class="line"></span><br><span class="line">### 1.3反射获取构造方法并使用</span><br><span class="line"></span><br><span class="line">##### Class类中用于获取构造方法的方法</span><br><span class="line"></span><br><span class="line">* Constructor&lt;?&gt;[] getConstructors()：返回所有公共构造方法对象的数组</span><br><span class="line">* Constructor&lt;?&gt;[] getDeclaredConstructors()：返回所有构造方法对象的数组</span><br><span class="line">* Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)：返回单个公共构造方法对象</span><br><span class="line">* Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;...parameterTyprs)：返回单个构造方法对象</span><br><span class="line"></span><br><span class="line">Constructor类中用于创建对象的方法</span><br><span class="line"></span><br><span class="line">* T newInstance(Object...initargs)：根据指定的构造方法创建对象</span><br><span class="line"></span><br><span class="line">### 1.4反射获取构造方法并使用练习</span><br><span class="line"></span><br><span class="line">##### 练习1：通过反射实现如下操作</span><br><span class="line"></span><br><span class="line">* Student s &#x3D; new Student(&quot;林青霞&quot;,30,&quot;西安&quot;);</span><br><span class="line"></span><br><span class="line">* System.out.println(s);</span><br><span class="line"></span><br><span class="line">  * &#96;&#96;&#96;java</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException,NoSuchMethodException</span><br><span class="line">    &#123;</span><br><span class="line">        Class&lt;?&gt; c &#x3D; Class.forName(&quot;com.bilibili.reflect.Student&quot;);</span><br><span class="line">        </span><br><span class="line">        Constructor&lt;?&gt; con &#x3D; c.getConstructor(String.class,int.class,String.class);</span><br><span class="line">        </span><br><span class="line">        Object obj &#x3D; con.newInstance(&quot;林青霞&quot;,30,&quot;西安&quot;);</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>基本类型也可以通过.class得到对应的Class类型</p>
</li>
<li><p>public void setAccessible(boolean flag)：值为true，取消访问检查（暴力访问）</p>
</li>
</ul>
<h3 id="1-5反射获取成员变量并使用"><a href="#1-5反射获取成员变量并使用" class="headerlink" title="1.5反射获取成员变量并使用"></a>1.5反射获取成员变量并使用</h3><h5 id="Class类中用于获取成员变量的方法"><a href="#Class类中用于获取成员变量的方法" class="headerlink" title="Class类中用于获取成员变量的方法"></a>Class类中用于获取成员变量的方法</h5><ul>
<li>Field[] getFields()：返回所有公共成员变量对象的数组</li>
<li>Field[] getDeclaredFields()：返回所有成员变量对象的数组</li>
<li>Field getField(String name)：返回单个公共成员变量对象</li>
<li>Field getDeclaredField(String name)：返回单个成员变量对象</li>
</ul>
<h5 id="Field类中用于给成员变量赋值的方法"><a href="#Field类中用于给成员变量赋值的方法" class="headerlink" title="Field类中用于给成员变量赋值的方法"></a>Field类中用于给成员变量赋值的方法</h5><ul>
<li>void set(Object obj,Object value)：给obj对象的成员变量赋值为value</li>
</ul>
<h3 id="1-6反射获取成员方法并使用"><a href="#1-6反射获取成员方法并使用" class="headerlink" title="1.6反射获取成员方法并使用"></a>1.6反射获取成员方法并使用</h3><h5 id="Class类中用于获取成员变量的方法-1"><a href="#Class类中用于获取成员变量的方法-1" class="headerlink" title="Class类中用于获取成员变量的方法"></a>Class类中用于获取成员变量的方法</h5><ul>
<li>Method[] getMethods()：返回所有公共成员方法对象的数组，包括继承的</li>
<li>Methods[] getDeclaredMethods()：返回所有成员方法对象的数组，不包括继承的</li>
<li>Method getMethod(Srting name,Class&lt;?&gt; …parameterTypes)：返回单个公共成员方法对象、</li>
<li>Method getDeclaredMethod(String name,Class&lt;?&gt; …parameterTypes)：返回单个成员方法对象</li>
</ul>
<h5 id="Method类中用于调用成员方法的方法"><a href="#Method类中用于调用成员方法的方法" class="headerlink" title="Method类中用于调用成员方法的方法"></a>Method类中用于调用成员方法的方法</h5><ul>
<li>Object invoke(Object obj,Object… args)：调用obj对象的成员方法，参数是args，返回值是Object类型</li>
</ul>
<h3 id="1-7反射练习"><a href="#1-7反射练习" class="headerlink" title="1.7反射练习"></a>1.7反射练习</h3><h5 id="练习1：越过泛型检查"><a href="#练习1：越过泛型检查" class="headerlink" title="练习1：越过泛型检查"></a>练习1：越过泛型检查</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bilibili.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectTest01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InvocationTargetException, IllegalAccessException, NoSuchMethodException </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; array = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        array.add(<span class="number">10</span>);</span><br><span class="line">        array.add(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(array);</span><br><span class="line"></span><br><span class="line">        Class&lt;? extends ArrayList&gt; c = array.getClass();</span><br><span class="line">        Method m = c.getMethod(<span class="string">&quot;add&quot;</span>, Object.class);</span><br><span class="line"></span><br><span class="line">        m.invoke(array,<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        System.out.println(array);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="运行配置文件指定内容"><a href="#运行配置文件指定内容" class="headerlink" title="运行配置文件指定内容"></a>运行配置文件指定内容</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;class.txt&quot;</span>);</span><br><span class="line">prop.load(fr);</span><br><span class="line">fr.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	class.txt内容如下</span></span><br><span class="line"><span class="comment">	className=com.bilibili.Student</span></span><br><span class="line"><span class="comment">	methodName=study</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">String className = prop.getProperty(<span class="string">&quot;className&quot;</span>);</span><br><span class="line">String methodName = prop.getProperty(<span class="string">&quot;methodName&quot;</span>);</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; c =  Class.forName(className);<span class="comment">//com.bilibili.Student</span></span><br><span class="line">Constructor&lt;?&gt; con = c.getConstructor();</span><br><span class="line">Object obj = con.newInstance();</span><br><span class="line"></span><br><span class="line">Method m = c.getMethod(methodName);<span class="comment">//study</span></span><br><span class="line">m.invoke(obj);</span><br></pre></td></tr></table></figure>

<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><h3 id="1-1模块的基本使用"><a href="#1-1模块的基本使用" class="headerlink" title="1.1模块的基本使用"></a>1.1模块的基本使用</h3><h5 id="模块的基本使用步骤"><a href="#模块的基本使用步骤" class="headerlink" title="模块的基本使用步骤"></a>模块的基本使用步骤</h5><ul>
<li>创建模块（按照以前的讲解方式创建模块，创建包，创建类，定义方法）</li>
<li>在模块的src目录下新建一个名为module-info.java的描述性文件，该文件专门定义模块名，访问权限，模块依赖等信息。描述性文件中使用模块导出和模块依赖进行配置使用</li>
<li>模块中所有未导出的包都是模块私有的，他们是不能在模块之外被访问的<ul>
<li>模块导出格式：exports 包名;</li>
</ul>
</li>
<li>一个模块要访问其他的模块，必须明确指定依赖哪些模块，未明确指定依赖的模块不能访问<ul>
<li>模块依赖格式：requires 模块名;</li>
<li>注意：写模块名报错，需要按下Alt+Enter提示，然后选择模块依赖</li>
</ul>
</li>
</ul>
<h3 id="1-2模块服务的使用"><a href="#1-2模块服务的使用" class="headerlink" title="1.2模块服务的使用"></a>1.2模块服务的使用</h3><h5 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h5><p>从Java6开始，Java提供了一种服务机制，允许服务提供者和服务使用者之间完成解耦，简单的说，就是服务使用者只面向接口编程，但不清楚服务提供者的实现类</p>
<hr>
<p>Java9允许将服务接口定义在一个模块中，并使用uses语句来声明该服务接口，然后针对该服务接口提供不同的服务实现类，这些服务实现类可以分布在不同的模块中，服务实现模块则使用provides语句为服务接口指定实现类。服务使用者只需要面向接口编程即可</p>
<h5 id="模块服务的使用步骤"><a href="#模块服务的使用步骤" class="headerlink" title="模块服务的使用步骤"></a>模块服务的使用步骤</h5><ul>
<li><p>在myOne模块下创建一个包com.itheima_03，在该包下提供一个接口，接口中定义一个抽象方法(MyService)</p>
</li>
<li><p>在com.itheima_03包下创建一个包impl，在该包下提供接口的两个实现类Itheima和Czxy</p>
</li>
<li><p>在myOne这个模块下的描述性文件中添加如下配置</p>
<ul>
<li>模块导出：exports com.itheima_03;</li>
<li>服务提供：provides MyService with Itheima;指定MyService的服务实现类是Itheima</li>
</ul>
</li>
<li><p>在myTwo这个模块下的描述性文件中添加如下配置</p>
<ul>
<li>声明服务接口：uses MyService;</li>
</ul>
</li>
<li><p>在myTwo这个模块的使用MyService接口提供的服务</p>
<ul>
<li>ServiceLoader：一种加载服务实现的工具</li>
</ul>
</li>
</ul>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">Water monster</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://manongtaoye.github.io/2021/05/09/Java/">https://manongtaoye.github.io/2021/05/09/Java/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">Water monster</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/note/">
                                    <span class="chip bg-color">note</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    
        <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments textarea {
        box-sizing: border-box;
        background: url("/medias/comment_bg.png") 100% 100% no-repeat;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #4cbf30;
        font-weight: 500;
        text-decoration: none;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; padding-left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="vcomments" class="card-content" style="display: grid">
    </div>
</div>

<script src="/libs/valine/av-min.js"></script>
<script src="/libs/valine/Valine.min.js"></script>
<script>
    new Valine({
        el: '#vcomments',
        appId: 'vdbExxBqH65oAeGcqAM3nHBC-gzGzoHsz',
        appKey: 'A7qpmJgGSTmQjMgR6sKlDHE3',
        notify: 'false' === 'true',
        verify: 'false' === 'true',
        visitor: 'true' === 'true',
        avatar: 'mm',
        pageSize: '10',
        lang: 'zh-cn',
        placeholder: 'just go go'
    });
</script>

<!--酷Q推送-->


    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2021/05/09/JavaScript/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/21.jpg" class="responsive-img" alt="JavaScript">
                        
                        <span class="card-title">JavaScript</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2021-05-09
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            Water monster
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2021/05/09/Mysql/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/18.jpg" class="responsive-img" alt="Mysql">
                        
                        <span class="card-title">Mysql</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-05-09
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            Water monster
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/note/">
                        <span class="chip bg-color">note</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('10')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: 水兽的Blog<br />'
            + '文章作者: Water monster<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='true'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2021-2022</span>
            
            <span id="year">2021</span>
            <a href="/about" target="_blank">Water monster</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">69.4k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/manongtaoye" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1513591616@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1513591616" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1513591616" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    
    <script type="text/javascript" color="0,0,255"
        pointColor="0,0,255" opacity='0.7'
        zIndex="-1" count="99"
        src="/libs/background/canvas-nest.js"></script>
    

    
    
    <script type="text/javascript" size="150" alpha='0.6'
        zIndex="-1" src="/libs/background/ribbon-refresh.min.js" async="async"></script>
    

    
    <script type="text/javascript" src="/libs/background/ribbon-dynamic.js" async="async"></script>
    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
